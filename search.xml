<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Dockerfile初探</title>
    <url>/2020/05/11/Dockerfile%E5%88%9D%E6%8E%A2/</url>
    <content><![CDATA[<h3 id="测试使用Dockerfile创建一个myshop镜像"><a href="#测试使用Dockerfile创建一个myshop镜像" class="headerlink" title="测试使用Dockerfile创建一个myshop镜像"></a>测试使用Dockerfile创建一个myshop镜像</h3><p>1.新建文件夹myshop</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir myshop</span><br><span class="line"><span class="comment">#查看当前目录</span></span><br><span class="line"><span class="built_in">pwd</span></span><br><span class="line">/Users/doubledumbao/docker-demo/202005/myshop</span><br></pre></td></tr></table></figure>

<p>2.新建index.html文件，文件内容如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>hello docker <span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>hello docker!!!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>3.将index.html打包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -zcvf myshop.tar.gz index.html</span><br></pre></td></tr></table></figure>

<p>4.编写Dockerfile文件</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># FROM 指令用于指定其后构建新镜像所使用的基础镜像。FROM 指令必是 Dockerfile 文件中的首条命令，启动构建流程后，Docker 将会基于该镜像构建新镜像，FROM 后的命令也会基于这个基础镜像。</span></span><br><span class="line"><span class="keyword">FROM</span> tomcat:latest</span><br><span class="line"><span class="comment"># 删除/usr/local/tomcat/webapps/ROOT/目录下的内容</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> rm -rf /usr/<span class="built_in">local</span>/tomcat/webapps/ROOT/*</span></span><br><span class="line"><span class="comment"># COPY 指令将从构建上下文目录中 &lt;源路径&gt; 的文件/目录复制到新的一层的镜像内的&amp;lt;目标路径&amp;gt;位置。</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> myshop.tar.gz /usr/<span class="built_in">local</span>/tomcat/webapps/ROOT/</span></span><br><span class="line"><span class="comment"># WORKDIR用于在容器内设置一个工作目录</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /usr/<span class="built_in">local</span>/tomcat/webapps/ROOT/</span></span><br><span class="line"><span class="comment"># RUN在镜像的构建过程中执行特定的命令，并生成一个中间镜像。</span></span><br><span class="line"><span class="comment"># 解压tar包并删除tar包</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> tar -zxvf myshop.tar.gz \</span></span><br><span class="line"><span class="bash">   &amp;&amp; rm -fr myshop.tar.gz</span></span><br><span class="line"><span class="comment"># 为构建的镜像设置监听端口，使容器在运行时监听。格式：EXPOSE &lt;port&gt; [&lt;port&gt;...]。EXPOSE 指令并不会让容器监听 host 的端口，如果需要，需要在 docker run 时使用 -p、-P 参数来发布容器端口到 host 的某个端口上。</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure>

<p>5.编译Dockerfile</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker build -t myshop .</span><br></pre></td></tr></table></figure>

<p>6.运行容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker build -t myshop .</span><br></pre></td></tr></table></figure>

<p>7.查看浏览器localhost:8080效果</p>
<p>8.查看容器内目录结构，使用命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it 11474d41fac5 /bin/bash</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap源码详解和面试题分析</title>
    <url>/2020/05/09/HashMap%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3%E5%92%8C%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>docker服务编排</title>
    <url>/2020/05/08/docker%E6%9C%8D%E5%8A%A1%E7%BC%96%E6%8E%92/</url>
    <content><![CDATA[<p><strong><em>根据哔哩哔哩视频<a href="https://www.bilibili.com/video/BV1Wt411w72h/?spm_id_from=333.788.videocard.0" target="_blank" rel="noopener">【docker入门2】实战~如何组织一个多容器项目docker-compose</a>进行学习</em></strong></p>
<h2 id="利用网站https-labs-play-with-docker-com-进行测试"><a href="#利用网站https-labs-play-with-docker-com-进行测试" class="headerlink" title="利用网站https://labs.play-with-docker.com/进行测试"></a>利用网站<a href="https://labs.play-with-docker.com/进行测试" target="_blank" rel="noopener">https://labs.play-with-docker.com/进行测试</a></h2><h3 id="第一步，安装nginx镜像"><a href="#第一步，安装nginx镜像" class="headerlink" title="第一步，安装nginx镜像"></a>第一步，安装nginx镜像</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 拉取nginx镜像</span></span><br><span class="line">docker pull nginx</span><br><span class="line"><span class="comment"># 运行nginx容器</span></span><br><span class="line">docker run -d -p80:80 --name mynginx nginx </span><br><span class="line"><span class="comment">#容器ID</span></span><br><span class="line">87702c4c192061036d731df8f533a82f20b972284b650a850adec3aba9580342</span><br><span class="line"><span class="comment"># 查看运行中的容器</span></span><br><span class="line">docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                NAMES</span><br><span class="line">87702c4c1920        nginx               <span class="string">"nginx -g 'daemon of…"</span>   24 seconds ago      Up 23 seconds       0.0.0.0:80-&gt;80/tcp   mynginx </span><br><span class="line"><span class="comment"># 在容器中进行交互操作</span></span><br><span class="line">docker <span class="built_in">exec</span> -it mynginx /bin/bash</span><br><span class="line"><span class="comment"># 查看容器IP地址</span></span><br><span class="line">cat /etc/hosts</span><br><span class="line"></span><br><span class="line">127.0.0.1	localhost</span><br><span class="line">::1	localhost ip6-localhost ip6-loopback</span><br><span class="line">fe00::0	ip6-localnet</span><br><span class="line">ff00::0	ip6-mcastprefix</span><br><span class="line">ff02::1	ip6-allnodes</span><br><span class="line">ff02::2	ip6-allrouters</span><br><span class="line">172.17.0.2	87702c4c1920</span><br></pre></td></tr></table></figure>
<h3 id="第二步：安装最小化Linux镜像alpine"><a href="#第二步：安装最小化Linux镜像alpine" class="headerlink" title="第二步：安装最小化Linux镜像alpine"></a>第二步：安装最小化Linux镜像alpine</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 拉取alpine镜像</span></span><br><span class="line">docker pull alpine</span><br><span class="line"><span class="comment"># 安装curl</span></span><br><span class="line">apk add curl</span><br><span class="line"><span class="comment"># curl nginx容器</span></span><br><span class="line">curl 172.17.0.2</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;Welcome to nginx!&lt;/title&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">    body &#123;</span><br><span class="line">        width: 35em;</span><br><span class="line">        margin: 0 auto;</span><br><span class="line">        font-family: Tahoma, Verdana, Arial, sans-serif;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;</span><br><span class="line">&lt;p&gt;If you see this page, the nginx web server is successfully installed and</span><br><span class="line">working. Further configuration is required.&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;For online documentation and support please refer to</span><br><span class="line">&lt;a href=<span class="string">"http://nginx.org/"</span>&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;</span><br><span class="line">Commercial support is available at</span><br><span class="line">&lt;a href=<span class="string">"http://nginx.com/"</span>&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;&lt;em&gt;Thank you <span class="keyword">for</span> using nginx.&lt;/em&gt;&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h3 id="另外一种方式-–link方式"><a href="#另外一种方式-–link方式" class="headerlink" title="另外一种方式 –link方式"></a>另外一种方式 –link方式</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#后台运行alpine,并将mynginx容器绑定域名myng</span></span><br><span class="line">docker run -dit --link mynginx:myng alpine   </span><br><span class="line">825d4b3d221238bda2f29411fcae6d72fafb97d5002986660aa8c3b7cc501d99</span><br><span class="line"><span class="comment"># 安装curl</span></span><br><span class="line">apk add curl</span><br><span class="line"></span><br><span class="line">fetch http://dl-cdn.alpinelinux.org/alpine/v3.11/main/x86_64/APKINDEX.tar.gz</span><br><span class="line">fetch http://dl-cdn.alpinelinux.org/alpine/v3.11/community/x86_64/APKINDEX.tar.gz</span><br><span class="line">(1/4) Installing ca-certificates (20191127-r1)</span><br><span class="line">(2/4) Installing nghttp2-libs (1.40.0-r0)</span><br><span class="line">(3/4) Installing libcurl (7.67.0-r0)</span><br><span class="line">(4/4) Installing curl (7.67.0-r0)</span><br><span class="line">Executing busybox-1.31.1-r9.trigger</span><br><span class="line">Executing ca-certificates-20191127-r1.trigger</span><br><span class="line">OK: 7 MiB <span class="keyword">in</span> 18 packages</span><br><span class="line"><span class="comment"># curl nginx镜像</span></span><br><span class="line">curl myng</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;Welcome to nginx!&lt;/title&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">    body &#123;</span><br><span class="line">        width: 35em;</span><br><span class="line">        margin: 0 auto;</span><br><span class="line">        font-family: Tahoma, Verdana, Arial, sans-serif;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;</span><br><span class="line">&lt;p&gt;If you see this page, the nginx web server is successfully installed and</span><br><span class="line">working. Further configuration is required.&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;For online documentation and support please refer to</span><br><span class="line">&lt;a href=<span class="string">"http://nginx.org/"</span>&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;</span><br><span class="line">Commercial support is available at</span><br><span class="line">&lt;a href=<span class="string">"http://nginx.com/"</span>&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;&lt;em&gt;Thank you <span class="keyword">for</span> using nginx.&lt;/em&gt;&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 原理，增加了172.17.0.2      myng d2d78de2ad2f</span></span><br><span class="line">cat /etc/hosts</span><br><span class="line">127.0.0.1       localhost</span><br><span class="line">::1     localhost ip6-localhost ip6-loopback</span><br><span class="line">fe00::0 ip6-localnet</span><br><span class="line">ff00::0 ip6-mcastprefix</span><br><span class="line">ff02::1 ip6-allnodes</span><br><span class="line">ff02::2 ip6-allrouters</span><br><span class="line">172.17.0.2      myng d2d78de2ad2f</span><br><span class="line">172.17.0.3      9688a42fec94</span><br></pre></td></tr></table></figure>

<h3 id="docker-compose方式"><a href="#docker-compose方式" class="headerlink" title="docker-compose方式"></a>docker-compose方式</h3><h4 id="Users-doubledumbao-docker-demo-compose-demo目录下，新建html目录，添加index-html"><a href="#Users-doubledumbao-docker-demo-compose-demo目录下，新建html目录，添加index-html" class="headerlink" title="/Users/doubledumbao/docker-demo/compose-demo目录下，新建html目录，添加index.html"></a>/Users/doubledumbao/docker-demo/compose-demo目录下，新建html目录，添加index.html</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>hello world nginx<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>hello world nginx!!!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="Users-doubledumbao-docker-demo-compose-demo-html目录下，添加test-php"><a href="#Users-doubledumbao-docker-demo-compose-demo-html目录下，添加test-php" class="headerlink" title="/Users/doubledumbao/docker-demo/compose-demo/html目录下，添加test.php"></a>/Users/doubledumbao/docker-demo/compose-demo/html目录下，添加test.php</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"Hello World PHP!!!"</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h4 id="Users-doubledumbao-docker-demo-compose-demo-html目录下，添加mysql-php"><a href="#Users-doubledumbao-docker-demo-compose-demo-html目录下，添加mysql-php" class="headerlink" title="/Users/doubledumbao/docker-demo/compose-demo/html目录下，添加mysql.php"></a>/Users/doubledumbao/docker-demo/compose-demo/html目录下，添加mysql.php</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$servername = <span class="string">"mysql"</span>;</span><br><span class="line">$username = <span class="string">"root"</span>;</span><br><span class="line">$password = <span class="string">"123456"</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 创建连接</span></span><br><span class="line">$conn = <span class="keyword">new</span> mysqli($servername, $username, $password);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 检测连接</span></span><br><span class="line"><span class="keyword">if</span> ($conn-&gt;connect_error) &#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">"连接失败: "</span> . $conn-&gt;connect_error);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">echo</span> <span class="string">"connected success !!!!!"</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="Users-doubledumbao-docker-demo-compose-demo目录下，新建conf目录"><a href="#Users-doubledumbao-docker-demo-compose-demo目录下，新建conf目录" class="headerlink" title="/Users/doubledumbao/docker-demo/compose-demo目录下，新建conf目录"></a>/Users/doubledumbao/docker-demo/compose-demo目录下，新建conf目录</h4><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment">#user  nobody;</span></span><br><span class="line"><span class="attribute">worker_processes</span>  <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#error_log  logs/error.log;</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log  notice;</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log  info;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#pid        logs/nginx.pid;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>       mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '</span></span><br><span class="line">    <span class="comment">#                  '$status $body_bytes_sent "$http_referer" '</span></span><br><span class="line">    <span class="comment">#                  '"$http_user_agent" "$http_x_forwarded_for"';</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#access_log  logs/access.log  main;</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line">    <span class="comment">#tcp_nopush     on;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#keepalive_timeout  0;</span></span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#gzip  on;</span></span><br><span class="line"></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span>  localhost;</span><br><span class="line"></span><br><span class="line">        <span class="comment">#charset koi8-r;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#access_log  logs/host.access.log  main;</span></span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">            <span class="attribute">root</span>   /usr/share/nginx/html;</span><br><span class="line">            <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">#error_page  404              /404.html;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># redirect server error pages to the static page /50x.html</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="attribute">error_page</span>   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /50x.html;</span><br><span class="line">        <span class="attribute">location</span> = /50x.html &#123;</span><br><span class="line">            <span class="attribute">root</span>   html;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># proxy the PHP scripts to Apache listening on 127.0.0.1:80</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment"># location ~ \.php$ &#123;</span></span><br><span class="line">        <span class="comment">#    proxy_pass   http://127.0.0.1;</span></span><br><span class="line">        <span class="comment"># &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="attribute">location</span> <span class="regexp">~ \.php$</span> &#123;</span><br><span class="line">           <span class="attribute">fastcgi_pass</span>   php:<span class="number">9000</span>;</span><br><span class="line">           <span class="attribute">fastcgi_index</span>  index.php;</span><br><span class="line">           <span class="attribute">fastcgi_param</span>  SCRIPT_FILENAME  /var/www/html/<span class="variable">$fastcgi_script_name</span>;</span><br><span class="line">           <span class="attribute">include</span>        fastcgi_params;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># deny access to .htaccess files, if Apache's document root</span></span><br><span class="line">        <span class="comment"># concurs with nginx's one</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment">#location ~ /\.ht &#123;</span></span><br><span class="line">        <span class="comment">#    deny  all;</span></span><br><span class="line">        <span class="comment">#&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># another virtual host using mix of IP-, name-, and port-based configuration</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#server &#123;</span></span><br><span class="line">    <span class="comment">#    listen       8000;</span></span><br><span class="line">    <span class="comment">#    listen       somename:8080;</span></span><br><span class="line">    <span class="comment">#    server_name  somename  alias  another.alias;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#    location / &#123;</span></span><br><span class="line">    <span class="comment">#        root   html;</span></span><br><span class="line">    <span class="comment">#        index  index.html index.htm;</span></span><br><span class="line">    <span class="comment">#    &#125;</span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># HTTPS server</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#server &#123;</span></span><br><span class="line">    <span class="comment">#    listen       443 ssl;</span></span><br><span class="line">    <span class="comment">#    server_name  localhost;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#    ssl_certificate      cert.pem;</span></span><br><span class="line">    <span class="comment">#    ssl_certificate_key  cert.key;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#    ssl_session_cache    shared:SSL:1m;</span></span><br><span class="line">    <span class="comment">#    ssl_session_timeout  5m;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#    ssl_ciphers  HIGH:!aNULL:!MD5;</span></span><br><span class="line">    <span class="comment">#    ssl_prefer_server_ciphers  on;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#    location / &#123;</span></span><br><span class="line">    <span class="comment">#        root   html;</span></span><br><span class="line">    <span class="comment">#        index  index.html index.htm;</span></span><br><span class="line">    <span class="comment">#    &#125;</span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Users-doubledumbao-docker-demo-compose-demo目录下，添加docker-compose-yml"><a href="#Users-doubledumbao-docker-demo-compose-demo目录下，添加docker-compose-yml" class="headerlink" title="/Users/doubledumbao/docker-demo/compose-demo目录下，添加docker-compose.yml"></a>/Users/doubledumbao/docker-demo/compose-demo目录下，添加docker-compose.yml</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span> </span><br><span class="line">    <span class="attr">nginx:</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:alpine</span></span><br><span class="line">        <span class="attr">ports:</span> </span><br><span class="line">        <span class="bullet">-</span> <span class="number">80</span><span class="string">:80</span></span><br><span class="line">        <span class="attr">volumes:</span> </span><br><span class="line">        <span class="bullet">-</span> <span class="string">/Users/doubledumbao/docker-demo/compose-demo/html:/usr/share/nginx/html</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">/Users/doubledumbao/docker-demo/compose-demo/conf/nginx.conf:/etc/nginx/nginx.conf</span></span><br><span class="line">    <span class="attr">php:</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">devilbox/php-fpm:5.2-work-0.89</span></span><br><span class="line">        <span class="attr">volumes:</span> </span><br><span class="line">        <span class="bullet">-</span> <span class="string">/Users/doubledumbao/docker-demo/compose-demo/html:/var/www/html</span></span><br><span class="line">    <span class="attr">mysql:</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">mysql:5.6</span></span><br><span class="line">        <span class="attr">environment:</span> </span><br><span class="line">        <span class="bullet">-</span> <span class="string">MYSQL_ROOT_PASSWORD=123456</span></span><br></pre></td></tr></table></figure>

<h4 id="启动docker-compose"><a href="#启动docker-compose" class="headerlink" title="启动docker-compose"></a>启动docker-compose</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker-compose up</span><br></pre></td></tr></table></figure>

<h4 id="打开浏览器，查看效果"><a href="#打开浏览器，查看效果" class="headerlink" title="打开浏览器，查看效果"></a>打开浏览器，查看效果</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看nginx配置效果</span></span><br><span class="line">http://localhost</span><br><span class="line"><span class="comment"># 查看php配置效果</span></span><br><span class="line">http://localhost/test.php</span><br><span class="line"><span class="comment"># 查看mysql配置效果</span></span><br><span class="line">http://localhost/mysql.php</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程问题整理</title>
    <url>/2020/05/06/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h2 id="1-如何实现一个生产者和消费者模型？（锁、信号量、线程通信、阻塞队列等）"><a href="#1-如何实现一个生产者和消费者模型？（锁、信号量、线程通信、阻塞队列等）" class="headerlink" title="1.如何实现一个生产者和消费者模型？（锁、信号量、线程通信、阻塞队列等）"></a>1.如何实现一个生产者和消费者模型？（锁、信号量、线程通信、阻塞队列等）</h2><p><a href="https://www.jianshu.com/p/66e8b5ab27f6" target="_blank" rel="noopener">Java生产者和消费者模型的5种实现方式</a></p>
<h2 id="2-如何理解线程的同步和异步、阻塞和非阻塞？"><a href="#2-如何理解线程的同步和异步、阻塞和非阻塞？" class="headerlink" title="2.如何理解线程的同步和异步、阻塞和非阻塞？"></a>2.如何理解线程的同步和异步、阻塞和非阻塞？</h2><p>作者：Yi Lu<br>链接：<a href="https://www.zhihu.com/question/19732473/answer/20851256" target="_blank" rel="noopener">https://www.zhihu.com/question/19732473/answer/20851256</a><br>来源：知乎</p>
<p>“阻塞”与”非阻塞”与”同步”与“异步”不能简单的从字面理解，提供一个从分布式系统角度的回答。<br><strong>1.同步与异步</strong><br>    同步和异步关注的是<strong>消息通信机制</strong> (synchronous communication/ asynchronous communication)<br>所谓同步，就是在发出一个<em>调用</em>时，在没有得到结果之前，该<em>调用</em>就不返回。但是一旦调用返回，就得到返回值了。<br>换句话说，就是由<em>调用者</em>主动等待这个<em>调用</em>的结果。</p>
<p>而异步则是相反，<strong><em>调用\</em>在发出之后，这个调用就直接返回了，所以没有返回结果</strong>。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在<em>调用</em>发出后，<em>被调用者</em>通过状态、通知来通知调用者，或通过回调函数处理这个调用。</p>
<p>典型的异步编程模型比如Node.js</p>
<p>举个通俗的例子：<br>你打电话问书店老板有没有《分布式系统》这本书，如果是同步通信机制，书店老板会说，你稍等，”我查一下”，然后开始查啊查，等查好了（可能是5秒，也可能是一天）告诉你结果（返回结果）。<br>而异步通信机制，书店老板直接告诉你我查一下啊，查好了打电话给你，然后直接挂电话了（不返回结果）。然后查好了，他会主动打电话给你。在这里老板通过“回电”这种方式来回调。</p>
<ol start="2">
<li><p>阻塞与非阻塞</p>
<p>阻塞和非阻塞关注的是<strong>程序在等待调用结果（消息，返回值）时的状态.</strong></p>
</li>
</ol>
<p>阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。<br>非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。</p>
<p>还是上面的例子，<br>你打电话问书店老板有没有《分布式系统》这本书，你如果是阻塞式调用，你会一直把自己“挂起”，直到得到这本书有没有的结果，如果是非阻塞式调用，你不管老板有没有告诉你，你自己先一边去玩了， 当然你也要偶尔过几分钟check一下老板有没有返回结果。<br>在这里阻塞与非阻塞与是否同步异步无关。跟老板通过什么方式回答你结果无关。</p>
<p>如果是关心阻塞 IO/ 异步 IO, 参考  Unix Network Programming <a href="https://link.zhihu.com/?target=http%3A//english.tebyan.net/newindex.aspx%3Fpid%3D31159%26BookID%3D23760%26PageIndex%3D92%26Language%3D3">View Book</a></p>
<p>还是2014年写的以解释概念为主，主要是同步异步 阻塞和非阻塞会被用在不同层面上，可能会有不准确的地方，并没有针对 阻塞 IO/ 异步 IO 等进行讨论，大家可以后续看看这两个回答：</p>
<p><a href="https://www.zhihu.com/question/19732473/answer/14413599" target="_blank" rel="noopener">怎样理解阻塞非阻塞与同步异步的区别？</a></p>
<p><a href="https://www.zhihu.com/question/19732473/answer/241673170" target="_blank" rel="noopener">怎样理解阻塞非阻塞与同步异步的区别？</a></p>
<h2 id="3-线程池处理任务的流程是怎样的？"><a href="#3-线程池处理任务的流程是怎样的？" class="headerlink" title="3.线程池处理任务的流程是怎样的？"></a>3.线程池处理任务的流程是怎样的？</h2><p>1，首先线程池判断基本线程池是否已满（&lt; corePoolSize ？）？没满，创建一个工作线程来执行任务。满了，则进入下个流程。</p>
<p>2，其次线程池判断工作队列是否已满？没满，则将新提交的任务存储在工作队列里。满了，则进入下个流程。</p>
<p>3，最后线程池判断整个线程池是否已满（&lt; maximumPoolSize ？）？没满，则创建一个新的工作线程来执行任务，满了，则交给饱和策略来处理这个任务。</p>
<p>总结：线程池优先要创建出基本线程池大小（corePoolSize）的线程数量，没有达到这个数量时，每次提交新任务都会直接创建一个新线程，当达到了基本线程数量后，又有新任务到达，优先放入等待队列，如果队列满了，才去创建新的线程（不能超过线程池的最大数maxmumPoolSize）</p>
<h2 id="4-wait和sleep有什么不同？"><a href="#4-wait和sleep有什么不同？" class="headerlink" title="4.wait和sleep有什么不同？"></a>4.wait和sleep有什么不同？</h2><h3 id="区别1：使用限制"><a href="#区别1：使用限制" class="headerlink" title="区别1：使用限制"></a>区别1：使用限制</h3><p>使用 sleep 方法可以让让当前线程休眠，时间一到当前线程继续往下执行，在任何地方都能使用，但需要捕获 InterruptedException 异常。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    Thread.sleep(3000L);</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而使用 wait 方法则必须放在 synchronized 块里面，同样需要捕获 InterruptedException 异常，并且需要获取对象的锁。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">synchronized (lock)&#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        lock.wait();</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而且 wait 还需要额外的方法 notify/ notifyAll 进行唤醒，它们同样需要放在 synchronized 块里面，且获取对象的锁。。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">synchronized (lock) &#123;</span><br><span class="line">    &#x2F;&#x2F; 随机唤醒</span><br><span class="line">    lock.notify();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 唤醒全部</span><br><span class="line">    lock.notifyAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然也可以使用带时间的 wait(long millis) 方法，时间一到，无需其他线程唤醒，也会重新竞争获取对象的锁继续执行。</p>
<h3 id="区别2：使用场景"><a href="#区别2：使用场景" class="headerlink" title="区别2：使用场景"></a>区别2：使用场景</h3><p>sleep 一般用于当前线程休眠，或者轮循暂停操作，wait 则多用于多线程之间的通信。</p>
<h3 id="区别3：所属类"><a href="#区别3：所属类" class="headerlink" title="区别3：所属类"></a>区别3：所属类</h3><p>sleep 是 Thread 类的静态本地方法，wait 则是 Object 类的本地方法。</p>
<blockquote>
<p>java.lang.Thread#sleep</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static native void sleep(long millis) throws InterruptedException;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>java.lang.Object#wait</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final native void wait(long timeout) throws InterruptedException;</span><br></pre></td></tr></table></figure>

<p><strong>为什么要这样设计呢？</strong></p>
<p>因为 sleep 是让当前线程休眠，不涉及到对象类，也不需要获得对象的锁，所以是线程类的方法。wait 是让获得对象锁的线程实现等待，前提是要楚获得对象的锁，所以是类的方法。</p>
<h3 id="区别4：释放锁"><a href="#区别4：释放锁" class="headerlink" title="区别4：释放锁"></a>区别4：释放锁</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object lock &#x3D; new Object();</span><br><span class="line">synchronized (lock) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        lock.wait(3000L);</span><br><span class="line">        Thread.sleep(2000L);</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上代码所示，wait 可以释放当前线程对 lock 对象锁的持有，而 sleep 则不会。</p>
<h3 id="区别5：线程切换"><a href="#区别5：线程切换" class="headerlink" title="区别5：线程切换"></a>区别5：线程切换</h3><p>sleep 会让出 CPU 执行时间且强制上下文切换，而 wait 则不一定，wait 后可能还是有机会重新竞争到锁继续执行的。</p>
<h2 id="5-Synchronized和ReentrantLock有什么不同？各适合什么场景？"><a href="#5-Synchronized和ReentrantLock有什么不同？各适合什么场景？" class="headerlink" title="5.Synchronized和ReentrantLock有什么不同？各适合什么场景？"></a>5.Synchronized和ReentrantLock有什么不同？各适合什么场景？</h2><h5 id="1、ReentrantLock-拥有Synchronized相同的并发性和内存语义，此外还多了锁投票，定时锁等候和中断锁等候"><a href="#1、ReentrantLock-拥有Synchronized相同的并发性和内存语义，此外还多了锁投票，定时锁等候和中断锁等候" class="headerlink" title="1、ReentrantLock 拥有Synchronized相同的并发性和内存语义，此外还多了锁投票，定时锁等候和中断锁等候"></a>1、ReentrantLock 拥有Synchronized相同的并发性和内存语义，此外还多了<strong>锁投票</strong>，<strong>定时锁等候</strong>和<strong>中断锁等候</strong></h5><h6 id="example：线程A和B都要获取对象O的锁定，假设A获取了对象O锁，B将等待A释放对O的锁定，如果使用-synchronized-，如果A不释放，B将一直等下去，不能被中断如果-使用ReentrantLock，如果A不释放，可以使B在等待了足够长的时间以后，中断等待，而干别的事情"><a href="#example：线程A和B都要获取对象O的锁定，假设A获取了对象O锁，B将等待A释放对O的锁定，如果使用-synchronized-，如果A不释放，B将一直等下去，不能被中断如果-使用ReentrantLock，如果A不释放，可以使B在等待了足够长的时间以后，中断等待，而干别的事情" class="headerlink" title="example：线程A和B都要获取对象O的锁定，假设A获取了对象O锁，B将等待A释放对O的锁定，如果使用 synchronized ，如果A不释放，B将一直等下去，不能被中断如果 使用ReentrantLock，如果A不释放，可以使B在等待了足够长的时间以后，中断等待，而干别的事情"></a><em>example：</em>线程A和B都要获取对象O的锁定，假设A获取了对象O锁，B将等待A释放对O的锁定，如果使用 synchronized ，如果A不释放，B将一直等下去，不能被中断如果 使用ReentrantLock，如果A不释放，可以使B在等待了足够长的时间以后，中断等待，而干别的事情</h6><h6 id="ReentrantLock获取锁定与三种方式："><a href="#ReentrantLock获取锁定与三种方式：" class="headerlink" title="ReentrantLock获取锁定与三种方式："></a>ReentrantLock获取锁定与三种方式：</h6><ul>
<li><h6 id="lock-如果获取了锁立即返回，如果别的线程持有锁，当前线程则一直处于休眠状态，直到获取锁"><a href="#lock-如果获取了锁立即返回，如果别的线程持有锁，当前线程则一直处于休眠状态，直到获取锁" class="headerlink" title="lock(), 如果获取了锁立即返回，如果别的线程持有锁，当前线程则一直处于休眠状态，直到获取锁"></a>lock(), 如果获取了锁立即返回，如果别的线程持有锁，当前线程则一直处于休眠状态，直到获取锁</h6></li>
<li><h6 id="tryLock-如果获取了锁立即返回true，如果别的线程正持有锁，立即返回false；"><a href="#tryLock-如果获取了锁立即返回true，如果别的线程正持有锁，立即返回false；" class="headerlink" title="tryLock(), 如果获取了锁立即返回true，如果别的线程正持有锁，立即返回false；"></a>tryLock(), 如果获取了锁立即返回true，如果别的线程正持有锁，立即返回false；</h6></li>
<li><h6 id="tryLock-long-timeout-TimeUnit-unit-，-如果获取了锁定立即返回true，如果别的线程正持有锁，会等待参数给定的时间，在等待的过程中，如果获取了锁定，就返回true，如果等待超时，返回false；"><a href="#tryLock-long-timeout-TimeUnit-unit-，-如果获取了锁定立即返回true，如果别的线程正持有锁，会等待参数给定的时间，在等待的过程中，如果获取了锁定，就返回true，如果等待超时，返回false；" class="headerlink" title="tryLock(long timeout,TimeUnit unit)， 如果获取了锁定立即返回true，如果别的线程正持有锁，会等待参数给定的时间，在等待的过程中，如果获取了锁定，就返回true，如果等待超时，返回false；"></a>tryLock(long timeout,TimeUnit unit)， 如果获取了锁定立即返回true，如果别的线程正持有锁，会等待参数给定的时间，在等待的过程中，如果获取了锁定，就返回true，如果等待超时，返回false；</h6></li>
<li><h6 id="lockInterruptibly-如果获取了锁定立即返回，如果没有获取锁定，当前线程处于休眠状态，直到或者锁定，或者当前线程被别的线程中断"><a href="#lockInterruptibly-如果获取了锁定立即返回，如果没有获取锁定，当前线程处于休眠状态，直到或者锁定，或者当前线程被别的线程中断" class="headerlink" title="lockInterruptibly:如果获取了锁定立即返回，如果没有获取锁定，当前线程处于休眠状态，直到或者锁定，或者当前线程被别的线程中断"></a>lockInterruptibly:如果获取了锁定立即返回，如果没有获取锁定，当前线程处于休眠状态，直到或者锁定，或者当前线程被别的线程中断</h6></li>
</ul>
<hr>
<h5 id="2、synchronized是在JVM层面上实现的，不但可以通过一些监控工具监控synchronized的锁定，而且在代码执行时出现异常，JVM会自动释放锁定，但是使用Lock则不行，lock是通过代码实现的，要保证锁定一定会被释放，就必须将unLock-放到finally-中"><a href="#2、synchronized是在JVM层面上实现的，不但可以通过一些监控工具监控synchronized的锁定，而且在代码执行时出现异常，JVM会自动释放锁定，但是使用Lock则不行，lock是通过代码实现的，要保证锁定一定会被释放，就必须将unLock-放到finally-中" class="headerlink" title="2、synchronized是在JVM层面上实现的，不但可以通过一些监控工具监控synchronized的锁定，而且在代码执行时出现异常，JVM会自动释放锁定，但是使用Lock则不行，lock是通过代码实现的，要保证锁定一定会被释放，就必须将unLock()放到finally{}中"></a>2、synchronized是在<a href="https://link.jianshu.com?t=https://www.baidu.com/s?wd=JVM&tn=44039180_cpr&fenlei=mv6quAkxTZn0IZRqIHckPjm4nH00T1YkuWc1rHTdnWwbnH9-PW0z0ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3En1m3rjb1rH0Yn1fLnW01rj0Y" target="_blank" rel="noopener">JVM</a>层面上实现的，不但可以通过一些监控工具监控synchronized的锁定，而且在代码执行时出现异常，<a href="https://link.jianshu.com?t=http://baike.baidu.com/link?url=pUffiLWYkxesyD01y2WoXXiVVG988pvbc3GaaYXFW2TSZPhrH7_C8rRZBFwj7Prg_W8zn8p271NydxdolIh_U_" target="_blank" rel="noopener">JVM</a>会自动释放锁定，但是使用Lock则不行，lock是通过代码实现的，要保证锁定一定会被释放，就必须将unLock()放到finally{}中</h5><hr>
<h5 id="3、在资源竞争不是很激烈的情况下，Synchronized的性能要优于ReetrantLock，但是在资源竞争很激烈的情况下，Synchronized的性能会下降几十倍，但是ReetrantLock的性能能维持常态；"><a href="#3、在资源竞争不是很激烈的情况下，Synchronized的性能要优于ReetrantLock，但是在资源竞争很激烈的情况下，Synchronized的性能会下降几十倍，但是ReetrantLock的性能能维持常态；" class="headerlink" title="3、在资源竞争不是很激烈的情况下，Synchronized的性能要优于ReetrantLock，但是在资源竞争很激烈的情况下，Synchronized的性能会下降几十倍，但是ReetrantLock的性能能维持常态；"></a>3、在资源竞争不是很激烈的情况下，Synchronized的性能要优于ReetrantLock，但是在资源竞争很激烈的情况下，Synchronized的性能会下降几十倍，但是ReetrantLock的性能能维持常态；</h5><p>作者：OverLight<br>链接：<a href="https://www.jianshu.com/p/4dbacf1cadcf" target="_blank" rel="noopener">https://www.jianshu.com/p/4dbacf1cadcf</a><br>来源：简书</p>
<h2 id="6-读写锁适用于什么场景？ReentrantReadWriteLock是如何实现的？"><a href="#6-读写锁适用于什么场景？ReentrantReadWriteLock是如何实现的？" class="headerlink" title="6.读写锁适用于什么场景？ReentrantReadWriteLock是如何实现的？"></a>6.读写锁适用于什么场景？ReentrantReadWriteLock是如何实现的？</h2><p><a href="https://zhuanlan.zhihu.com/p/75879810" target="_blank" rel="noopener">ReentrantReadWriteLock读写锁详解</a></p>
<h2 id="7-线程之间如何通信？"><a href="#7-线程之间如何通信？" class="headerlink" title="7.线程之间如何通信？"></a>7.线程之间如何通信？</h2><p><a href="https://www.cnblogs.com/hapjin/p/5492619.html" target="_blank" rel="noopener"><a href="https://www.cnblogs.com/hapjin/p/5492619.html" target="_blank" rel="noopener">JAVA多线程之线程间的通信方式</a></a></p>
<h2 id="8-保证线程安全的方法有哪些？"><a href="#8-保证线程安全的方法有哪些？" class="headerlink" title="8.保证线程安全的方法有哪些？"></a>8.保证线程安全的方法有哪些？</h2><p><a href="https://www.nowcoder.com/questionTerminal/0e750e2953d144bd942bb1600b2a391e" target="_blank" rel="noopener">如何保证线程安全</a></p>
<h2 id="9-如何尽可能提高多线程并发性能？"><a href="#9-如何尽可能提高多线程并发性能？" class="headerlink" title="9.如何尽可能提高多线程并发性能？"></a>9.如何尽可能提高多线程并发性能？</h2><p><a href="https://my.oschina.net/u/1011494/blog/534822" target="_blank" rel="noopener">如何提高Java并行程序性能</a></p>
<h2 id="10-ThreadLocal用来解决什么问题？ThreadLocal是如何实现的？"><a href="#10-ThreadLocal用来解决什么问题？ThreadLocal是如何实现的？" class="headerlink" title="10.ThreadLocal用来解决什么问题？ThreadLocal是如何实现的？"></a>10.ThreadLocal用来解决什么问题？ThreadLocal是如何实现的？</h2><p><a href="https://baike.sogou.com/v54656329.htm?fromTitle=ThreadLocal" target="_blank" rel="noopener">ThreadLocal</a></p>
<h2 id="11-死锁的产生条件？如何分析是否有线程死锁？"><a href="#11-死锁的产生条件？如何分析是否有线程死锁？" class="headerlink" title="11.死锁的产生条件？如何分析是否有线程死锁？"></a>11.死锁的产生条件？如何分析是否有线程死锁？</h2><p><a href="https://zhuanlan.zhihu.com/p/84490319" target="_blank" rel="noopener">Java 多线程死锁的产生以及如何避免死锁</a></p>
<h2 id="12-在实际工作中遇到过什么样的并发问题，如何发现（排查）并解决的？"><a href="#12-在实际工作中遇到过什么样的并发问题，如何发现（排查）并解决的？" class="headerlink" title="12.在实际工作中遇到过什么样的并发问题，如何发现（排查）并解决的？"></a>12.在实际工作中遇到过什么样的并发问题，如何发现（排查）并解决的？</h2><p> <a href="https://www.cnblogs.com/koubeisi/p/10751035.html" target="_blank" rel="noopener"><a href="https://www.cnblogs.com/koubeisi/p/10751035.html" target="_blank" rel="noopener">Java面试 32个核心必考点完全解析</a></a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>多线程</category>
      </categories>
  </entry>
  <entry>
    <title>桥接模式</title>
    <url>/2020/05/03/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h1><p>桥接模式是将抽象部分与它的实现部分分离，使它们都可以独立地变化。它是一种对象<a href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=177096017&ss_c=ssc.citiao.link" target="_blank" rel="noopener">结构型模式</a>，又称为柄体(Handle and Body)模式或接口(Interfce)模式。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在软件系统中，某些类型由于自身的逻辑，它具有两个或多个维度的变化，那么如何应对这种“多维度的变化”？如何利用面向对象的技术来使得该类型能够轻松的沿着多个方向进行变化，而又不引入额外的复杂度？这就要使用Bridge模式。</p>
<h2 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h2><p>【GOF95】在提出桥梁模式的时候指出，桥梁模式的用意是”将<a href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=70235444&ss_c=ssc.citiao.link" target="_blank" rel="noopener">抽象化</a>(Abstraction)与实现化(Implementation)脱耦，使得二者可以独立地变化”。这句话有三个关键词，也就是抽象化、实现化和脱耦。</p>
<h3 id="抽象化"><a href="#抽象化" class="headerlink" title="抽象化"></a>抽象化</h3><p>存在于多个实体中的共同的概念性联系，就是抽象化。作为一个过程，抽象化就是忽略一些信息，从而把不同的实体当做同样的实体对待。</p>
<h3 id="实现化"><a href="#实现化" class="headerlink" title="实现化"></a>实现化</h3><p>抽象化给出的具体实现，就是实现化。</p>
<h3 id="脱耦"><a href="#脱耦" class="headerlink" title="脱耦"></a>脱耦</h3><p>所谓耦合，就是两个实体的行为的某种强关联。而将它们的强关联去掉，就是耦合的解脱，或称脱耦。在这里，脱耦是指将<a href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=70235444&ss_c=ssc.citiao.link" target="_blank" rel="noopener">抽象化</a>和实现化之间的耦合解脱开，或者说是将它们之间的强关联改换成弱关联。</p>
<p>将两个角色之间的继承关系改为<a href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=8918469&ss_c=ssc.citiao.link" target="_blank" rel="noopener">聚合关系</a>，就是将它们之间的强关联改换成为弱关联。因此，桥梁模式中的所谓脱耦，就是指在一个软件系统的抽象化和实现化之间使用组合/聚合关系而不是继承关系，从而使两者可以相对独立地变化。这就是桥梁模式的用意。</p>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>可以看出，这个系统含有两个等级结构，也就是：</p>
<p>由抽象化角色和修正抽象化角色组成的抽象化等级结构。</p>
<p>由实现化角色和两个具体实现化角色所组成的实现化等级结构。</p>
<p>桥梁模式所涉及的角色有：</p>
<p>抽象化(Abstraction)角色：抽象化给出的定义，并保存一个对实现化对象的引用。</p>
<p>修正抽象化(Refined Abstraction)角色：扩展抽象化角色，改变和修正父类对抽象化的定义。</p>
<p>实现化(Implementor)角色：这个角色给出实现化角色的接口，但不给出具体的实现。必须指出的是，这个接口不一定和抽象化角色的接口定义相同，实际上，这两个接口可以非常不一样。实现化角色应当只给出底层操作，而抽象化角色应当只给出基于底层操作的更高一层的操作。</p>
<p>具体实现化(Concrete Implementor)角色：这个角色给出实现化角色接口的具体实现。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 品牌</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Brand</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">info</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lenovo</span> <span class="keyword">implements</span> <span class="title">Brand</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"联想"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 苹果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apple</span>  <span class="keyword">implements</span>  <span class="title">Brand</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"苹果"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 电脑超类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Brand brand;<span class="comment">//组合品牌</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Computer</span><span class="params">(Brand brand)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.brand = brand;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span></span>&#123;</span><br><span class="line">        brand.info();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 笔记本电脑</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Desktop</span> <span class="keyword">extends</span> <span class="title">Computer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Desktop</span><span class="params">(Brand brand)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(brand);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.info();</span><br><span class="line">        System.out.println(<span class="string">"台式机"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 笔记本电脑</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Laptop</span> <span class="keyword">extends</span> <span class="title">Computer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Laptop</span><span class="params">(Brand brand)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(brand);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.info();</span><br><span class="line">        System.out.println(<span class="string">"笔记本电脑"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 平板电脑</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tablat</span> <span class="keyword">extends</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Tablat</span><span class="params">(Brand brand)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(brand);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.info();</span><br><span class="line">        System.out.println(<span class="string">"平板电脑"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Computer lenovo = <span class="keyword">new</span> Desktop(<span class="keyword">new</span> Lenovo());</span><br><span class="line">        lenovo.info();</span><br><span class="line"></span><br><span class="line">        Computer mac = <span class="keyword">new</span> Desktop(<span class="keyword">new</span> Apple());</span><br><span class="line">        mac.info();</span><br><span class="line"></span><br><span class="line">        Computer lenovo2 = <span class="keyword">new</span> Laptop(<span class="keyword">new</span> Lenovo());</span><br><span class="line">        lenovo2.info();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="模式优缺点"><a href="#模式优缺点" class="headerlink" title="模式优缺点"></a>模式优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>1、分离抽象接口及其实现部分。提高了比继承更好的解决方案。</li>
<li>2、桥接模式提高了系统的可扩充性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统。</li>
<li>3、实现细节对客户透明，可以对用户隐藏实现细节。</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>1、桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。</li>
<li>2、桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围具有一定的局限性。</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>maven依赖范围</title>
    <url>/2020/05/03/maven%E4%BE%9D%E8%B5%96%E8%8C%83%E5%9B%B4/</url>
    <content><![CDATA[<h1 id="依赖范围"><a href="#依赖范围" class="headerlink" title="依赖范围"></a>依赖范围</h1><blockquote>
<p>上一节提到，JUnit依赖的测试范围是test，测试范围用元素scope表示。本节将详细解释什么是测试范围，以及各种测试范围的效果和用途。</p>
<p>首先需要知道，Maven在编译项目主代码的时候需要使用一套classpath。在上例中，编译项目主代码的时候需要用到spring-core，该文件以依赖的方式被引入到classpath中。其次，Maven在编译和执行测试的时候会使用另外一套classpath。上例中的JUnit就是一个很好的例子，该文件也以依赖的方式引入到测试使用的classpath中，不同的是这里的依赖范围是test。最后，实际运行Maven项目的时候，又会使用一套classpath，上例中的spring-core需要在该classpath中，而JUnit则不需要。</p>
<p>依赖范围就是用来控制依赖与这三种classpath（编译classpath、测试classpath、运行classpath）的关系，Maven有以下几种依赖范围：</p>
<p>compile：编译依赖范围。如果没有指定，就会默认使用该依赖范围。使用此依赖范围的Maven依赖，对于编译、测试、运行三种classpath都有效。典型的例子是spring-core，在编译、测试和运行的时候都需要使用该依赖。</p>
<p>test：测试依赖范围。使用此依赖范围的Maven依赖，只对于测试classpath有效，在编译主代码或者运行项目的使用时将无法使用此类依赖。典型的例子是JUnit，它只有在编译测试代码及运行测试的时候才需要。</p>
<p>provided：已提供依赖范围。使用此依赖范围的Maven依赖，对于编译和测试class-path有效，但在运行时无效。典型的例子是servlet-api，编译和测试项目的时候需要该依赖，但在运行项目的时候，由于容器已经提供，就不需要Maven重复地引入一遍。</p>
<p>runtime：运行时依赖范围。使用此依赖范围的Maven依赖，对于测试和运行class-path有效，但在编译主代码时无效。典型的例子是JDBC驱动实现，项目主代码的编译只需要JDK提供的JDBC接口，只有在执行测试或者运行项目的时候才需要实现上述接口的具体JDBC驱动。</p>
<p>system：系统依赖范围。该依赖与三种classpath的关系，和provided依赖范围完全一致。但是，使用system范围的依赖时必须通过systemPath元素显式地指定依赖文件的路径。由于此类依赖不是通过Maven仓库解析的，而且往往与本机系统绑定，可能造成构建</p>
<p>“的不可移植，因此应该谨慎使用。systemPath元素可以引用环境变量，如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">＜dependency＞</span><br><span class="line">    ＜groupId＞javax.sql＜/groupId＞</span><br><span class="line">    ＜artifactId＞jdbc-stdext＜/artifactId＞</span><br><span class="line">    ＜version＞2.0＜/version＞</span><br><span class="line">    ＜scope＞system＜/scope＞</span><br><span class="line">    ＜systemPath＞$&#123;java.home&#125;/lib/rt.jar＜/systemPath＞</span><br><span class="line">＜/dependency＞</span><br></pre></td></tr></table></figure>

<p>import（Maven 2.0.9及以上）：导入依赖范围。该依赖范围不会对三种classpath产生实际的影响，本书将在8.3.3节介绍Maven依赖和dependencyManagement的时候详细介绍此依赖范围。</p>
</blockquote>
<p>摘录来自: 许晓斌. “Maven实战。” </p>
<p><a href="https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html#dependency-scope" target="_blank" rel="noopener">官网对scope的介绍</a></p>
<h3 id="Dependency-Scope"><a href="#Dependency-Scope" class="headerlink" title="Dependency Scope"></a>Dependency Scope</h3><p>Dependency scope is used to limit the transitivity of a dependency, and also to affect the classpath used for various build tasks.</p>
<p>There are 6 scopes available:</p>
<ul>
<li><strong>compile</strong><br>This is the default scope, used if none is specified. Compile dependencies are available in all classpaths of a project. Furthermore, those dependencies are propagated to dependent projects.</li>
<li><strong>provided</strong><br>This is much like <code>compile</code>, but indicates you expect the JDK or a container to provide the dependency at runtime. For example, when building a web application for the Java Enterprise Edition, you would set the dependency on the Servlet API and related Java EE APIs to scope <code>provided</code> because the web container provides those classes. This scope is only available on the compilation and test classpath, and is not transitive.</li>
<li><strong>runtime</strong><br>This scope indicates that the dependency is not required for compilation, but is for execution. It is in the runtime and test classpaths, but not the compile classpath.</li>
<li><strong>test</strong><br>This scope indicates that the dependency is not required for normal use of the application, and is only available for the test compilation and execution phases. This scope is not transitive.</li>
<li><strong>system</strong><br>This scope is similar to <code>provided</code> except that you have to provide the JAR which contains it explicitly. The artifact is always available and is not looked up in a repository.</li>
<li><strong>import</strong><br>This scope is only supported on a dependency of type <code>pom</code> in the <code>section. It indicates the dependency to be replaced with the effective list of dependencies in the specified POM&#39;s</code> section. Since they are replaced, dependencies with a scope of <code>import</code> do not actually participate in limiting the transitivity of a dependency.</li>
</ul>
<p>Each of the scopes (except for <code>import</code>) affects transitive dependencies in different ways, as is demonstrated in the table below. If a dependency is set to the scope in the left column, transitive dependencies of that dependency with the scope across the top row will result in a dependency in the main project with the scope listed at the intersection. If no scope is listed, it means the dependency will be omitted.</p>
<table>
<thead>
<tr>
<th></th>
<th>compile</th>
<th>provided</th>
<th>runtime</th>
<th>test</th>
</tr>
</thead>
<tbody><tr>
<td>compile</td>
<td>compile(*)</td>
<td>-</td>
<td>runtime</td>
<td>-</td>
</tr>
<tr>
<td>provided</td>
<td>provided</td>
<td>-</td>
<td>provided</td>
<td>-</td>
</tr>
<tr>
<td>runtime</td>
<td>runtime</td>
<td>-</td>
<td>runtime</td>
<td>-</td>
</tr>
<tr>
<td>test</td>
<td>test</td>
<td>-</td>
<td>test</td>
<td>-</td>
</tr>
</tbody></table>
<p><strong>(*) Note:</strong> it is intended that this should be runtime scope instead, so that all compile dependencies must be explicitly listed. However, if a library you depend on extends a class from another library, both must be available at compile time. For this reason, compile time dependencies remain as compile scope even when they are transitive.</p>
]]></content>
  </entry>
  <entry>
    <title>linux打开文件数 too many open files 解决办法</title>
    <url>/2020/05/03/linux%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E6%95%B0-too-many-open-files-%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    <content><![CDATA[<p><strong>阿里巴巴Java开发手册中规定：</strong></p>
<blockquote>
<p>调大服务器所支持的最大文件句柄数(File Descriptor，简写为fd)。 说明:主流操作系统的设计是将 TCP/UDP 连接采用与文件一样的方式去管理，即一个连接对 应于一个 fd。主流的 linux 服务器默认所支持最大 fd 数量为 1024，当并发连接数很大时很 容易因为 fd 不足而出现“open too many files”错误，导致新的连接无法建立。 建议将 linux 服务器所支持的最大句柄数调高数倍(与服务器的内存数量相关)。</p>
</blockquote>
<p><strong>查看每个用户最大允许打开文件数量</strong></p>
<blockquote>
<p>ulimit -a </p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">core file size          (blocks, -c) 0</span><br><span class="line">data seg size           (kbytes, -d) unlimited</span><br><span class="line">scheduling priority             (-e) 20</span><br><span class="line">file size               (blocks, -f) unlimited</span><br><span class="line">pending signals                 (-i) 16382</span><br><span class="line">max locked memory       (kbytes, -l) 64</span><br><span class="line">max memory size         (kbytes, -m) unlimited</span><br><span class="line">open files                      (-n) 1024</span><br><span class="line">pipe size            (512 bytes, -p) 8</span><br><span class="line">POSIX message queues     (bytes, -q) 819200</span><br><span class="line">real-time priority              (-r) 0</span><br><span class="line">stack size              (kbytes, -s) 8192</span><br><span class="line">cpu time               (seconds, -t) unlimited</span><br><span class="line">max user processes              (-u) unlimited</span><br><span class="line">virtual memory          (kbytes, -v) unlimited</span><br><span class="line">file locks                      (-x) unlimited</span><br></pre></td></tr></table></figure>

<p>查看某一进程的打开文件数量</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps -ef | grep java</span><br><span class="line">lsof -p 进程号 | wc -l</span><br></pre></td></tr></table></figure>

<p>设置open files数值方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ulimit -n 2048</span><br></pre></td></tr></table></figure>

<p><strong><em>这样就可以把当前用户的最大允许打开文件数量设置为2048了，但这种设置方法在重启后会还原为默认值。</em></strong></p>
<p><strong>永久设置方法</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;security&#x2F;limits.conf</span><br><span class="line">在最后加入</span><br><span class="line">* soft nofile 4096</span><br><span class="line">* hard nofile 4096</span><br></pre></td></tr></table></figure>

<p><strong><em>最前的表示所有用户，可根据需要设置某一用户，改完后注销一下就能生效。</em></strong></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>几个前端技术名词整理</title>
    <url>/2020/05/01/%E5%87%A0%E4%B8%AA%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF%E5%90%8D%E8%AF%8D%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h1 id="Babel-是什么？"><a href="#Babel-是什么？" class="headerlink" title="Babel 是什么？"></a>Babel 是什么？</h1><h2 id="Babel-是一个-JavaScript-编译器"><a href="#Babel-是一个-JavaScript-编译器" class="headerlink" title="Babel 是一个 JavaScript 编译器"></a>Babel 是一个 JavaScript 编译器</h2><p>Babel 是一个工具链，主要用于将 ECMAScript 2015+ 版本的代码转换为向后兼容的 JavaScript 语法，以便能够运行在当前和旧版本的浏览器或其他环境中。下面列出的是 Babel 能为你做的事情：</p>
<ul>
<li>语法转换</li>
<li>通过 Polyfill 方式在目标环境中添加缺失的特性 (通过 <a href="https://www.babeljs.cn/docs/babel-polyfill" target="_blank" rel="noopener">@babel/polyfill</a> 模块)</li>
<li>源码转换 (codemods)</li>
<li>更多！ (查看这些 <a href="https://www.babeljs.cn/videos.html" target="_blank" rel="noopener">视频</a> 获得启发)</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Babel 输入： ES2015 箭头函数</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="function">(<span class="params">n</span>) =&gt;</span> n + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Babel 输出： ES5 语法实现的同等功能</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> n + <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>参考地址：<a href="https://www.babeljs.cn/" target="_blank" rel="noopener">https://www.babeljs.cn/</a></p>
<h1 id="ESLint"><a href="#ESLint" class="headerlink" title="ESLint"></a>ESLint</h1><h2 id="About"><a href="#About" class="headerlink" title="About"></a>About</h2><p>ESLint 是一个开源的 JavaScript 代码检查工具，由 Nicholas C. Zakas 于2013年6月创建。代码检查是一种静态的分析，常用于寻找有问题的模式或者代码，并且不依赖于具体的编码风格。对大多数编程语言来说都会有代码检查，一般来说编译程序会内置检查工具。</p>
<p>JavaScript 是一个动态的弱类型语言，在开发中比较容易出错。因为没有编译程序，为了寻找 JavaScript 代码错误通常需要在执行过程中不断调试。像 ESLint 这样的可以让程序员在编码的过程中发现问题而不是在执行的过程中。</p>
<p>ESLint 的初衷是为了让程序员可以创建自己的检测规则。ESLint 的所有规则都被设计成可插入的。ESLint 的默认规则与其他的插件并没有什么区别，规则本身和测试可以依赖于同样的模式。为了便于人们使用，ESLint 内置了一些规则，当然，你可以在使用过程中自定义规则。</p>
<p>ESLint 使用 Node.js 编写，这样既可以有一个快速的运行环境的同时也便于安装。</p>
<h2 id="Philosophy"><a href="#Philosophy" class="headerlink" title="Philosophy"></a>Philosophy</h2><p>所有都是可拔插的</p>
<ul>
<li>内置规则和自定义规则共用一套规则 API</li>
<li>内置的格式化方法和自定义的格式化方法共用一套格式化 API</li>
<li>额外的规则和格式化方法能够在运行时指定</li>
<li>规则和对应的格式化方法并不强制捆绑使用</li>
</ul>
<p>每条规则:</p>
<ul>
<li>各自独立</li>
<li>可以开启或关闭（没有什么可以被认为“太重要所以不能关闭”）</li>
<li>可以将结果设置成警告或者错误</li>
</ul>
<p>另外:</p>
<ul>
<li>ESLint 并不推荐任何编码风格，规则是自由的</li>
<li>所有内置规则都是泛化的</li>
</ul>
<p>项目:</p>
<ul>
<li>通过丰富文档减少沟通成本</li>
<li>尽可能的简单透明</li>
<li>相信测试的重要性</li>
</ul>
<p>参考地址：<a href="http://eslint.cn/docs/user-guide/getting-started" target="_blank" rel="noopener">http://eslint.cn/docs/user-guide/getting-started</a></p>
<h1 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>本质上，<strong>webpack</strong> 是一个现代 JavaScript 应用程序的<em>静态模块打包工具</em>。当 webpack 处理应用程序时，它会在内部构建一个 <a href="https://webpack.docschina.org/concepts/dependency-graph/" target="_blank" rel="noopener">依赖图(dependency graph)</a>，此依赖图会映射项目所需的每个模块，并生成一个或多个 <em>bundle</em>。</p>
<blockquote>
<p>可以在 <a href="https://webpack.docschina.org/concepts/modules" target="_blank" rel="noopener">这里</a> 了解更多关于 JavaScript 模块和 webpack 模块的信息。</p>
</blockquote>
<p>从 v4.0.0 开始，<strong>webpack 可以不用再引入一个配置文件</strong>来打包项目，然而，但它仍然有着 <a href="https://webpack.docschina.org/configuration" target="_blank" rel="noopener">高度可配置性</a>，可以很好满足你的需求。</p>
<p>在开始前你需要先理解一些<strong>核心概念</strong>：</p>
<ul>
<li><a href="https://webpack.docschina.org/concepts/#entry" target="_blank" rel="noopener">入口(entry)</a></li>
<li><a href="https://webpack.docschina.org/concepts/#output" target="_blank" rel="noopener">输出(output)</a></li>
<li><a href="https://webpack.docschina.org/concepts/#loaders" target="_blank" rel="noopener">loader</a></li>
<li><a href="https://webpack.docschina.org/concepts/#plugins" target="_blank" rel="noopener">插件(plugin)</a></li>
<li><a href="https://webpack.docschina.org/concepts/#mode" target="_blank" rel="noopener">模式(mode)</a></li>
<li><a href="https://webpack.docschina.org/concepts/#browser-compatibility" target="_blank" rel="noopener">浏览器兼容性(browser compatibility)</a></li>
</ul>
<p>本文档旨在给出这些概念的<strong>高度</strong>概述，同时提供具体概念的详尽相关用例。</p>
<p>为了更好地理解模块打包工具背后的理念，以及在底层它们是如何运作的，请参考以下资源：</p>
<ul>
<li><a href="https://www.youtube.com/watch?v=UNMkLHzofQI" target="_blank" rel="noopener">手动打包一个应用程序</a></li>
<li><a href="https://www.youtube.com/watch?v=Gc9-7PBqOC8" target="_blank" rel="noopener">实时创建一个简单打包工具</a></li>
<li><a href="https://github.com/ronami/minipack" target="_blank" rel="noopener">一个简单打包工具的详细说明</a></li>
</ul>
<h2 id="入口-entry"><a href="#入口-entry" class="headerlink" title="入口(entry)"></a>入口(entry)</h2><p><strong>入口起点(entry point)</strong>指示 webpack 应该使用哪个模块，来作为构建其内部 <em><a href="https://webpack.docschina.org/concepts/dependency-graph/" target="_blank" rel="noopener">依赖图(dependency graph)</a></em> 的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。</p>
<p>默认值是 <code>./src/index.js</code>，但你可以通过在 <a href="https://webpack.docschina.org/configuration" target="_blank" rel="noopener">webpack configuration</a> 中配置 <strong>entry</strong> 属性，来指定一个（或多个）不同的入口起点。例如：</p>
<p><strong>webpack.config.js</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./path/to/my/entry/file.js'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在 <a href="https://webpack.docschina.org/concepts/entry-points" target="_blank" rel="noopener">入口起点</a> 章节可以了解更多信息。</p>
</blockquote>
<h2 id="输出-output"><a href="#输出-output" class="headerlink" title="输出(output)"></a>输出(output)</h2><p><strong>output</strong> 属性告诉 webpack 在哪里输出它所创建的 <em>bundle</em>，以及如何命名这些文件。主要输出文件的默认值是 <code>./dist/main.js</code>，其他生成文件默认放置在 <code>./dist</code> 文件夹中。</p>
<p>你可以通过在配置中指定一个 <code>output</code> 字段，来配置这些处理过程：</p>
<p><strong>webpack.config.js</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./path/to/my/entry/file.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'my-first-webpack.bundle.js'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们通过 <code>output.filename</code> 和 <code>output.path</code> 属性，来告诉 webpack bundle 的名称，以及我们想要 bundle 生成(emit)到哪里。可能你想要了解在代码最上面导入的 path 模块是什么，它是一个 <a href="https://nodejs.org/api/modules.html" target="_blank" rel="noopener">Node.js 核心模块</a>，用于操作文件路径。</p>
<blockquote>
<p><code>output</code> 属性还有 <a href="https://webpack.docschina.org/configuration/output" target="_blank" rel="noopener">许多可配置的特性</a>，如果你想要了解更多其背后的概念，你可以通过 <a href="https://webpack.docschina.org/concepts/output" target="_blank" rel="noopener">阅读输出章节</a> 来了解。</p>
</blockquote>
<h2 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h2><p>webpack 只能理解 JavaScript 和 JSON 文件。<strong>loader</strong> 让 webpack 能够去处理其他类型的文件，并将它们转换为有效 <a href="https://webpack.docschina.org/concepts/modules" target="_blank" rel="noopener">模块</a>，以供应用程序使用，以及被添加到依赖图中。</p>
<blockquote>
<p>注意，loader 能够 <code>import</code> 导入任何类型的模块（例如 <code>.css</code> 文件），这是 webpack 特有的功能，其他打包程序或任务执行器的可能并不支持。我们认为这种语言扩展是很有必要的，因为这可以使开发人员创建出更准确的依赖关系图。</p>
</blockquote>
<p>在更高层面，在 webpack 的配置中 <strong>loader</strong> 有两个属性：</p>
<ol>
<li><code>test</code> 属性，用于标识出应该被对应的 loader 进行转换的某个或某些文件。</li>
<li><code>use</code> 属性，表示进行转换时，应该使用哪个 loader。</li>
</ol>
<p><strong>webpack.config.js</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'my-first-webpack.bundle.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123; <span class="attr">test</span>: <span class="regexp">/\.txt$/</span>, <span class="attr">use</span>: <span class="string">'raw-loader'</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>以上配置中，对一个单独的 module 对象定义了 <code>rules</code> 属性，里面包含两个必须属性：<code>test</code> 和 <code>use</code>。这告诉 webpack 编译器(compiler) 如下信息：</p>
<blockquote>
<p>“嘿，webpack 编译器，当你碰到「在 <code>require()</code>/<code>import</code> 语句中被解析为 ‘.txt’ 的路径」时，在你对它打包之前，先 <strong>使用</strong> <code>raw-loader</code> 转换一下。”</p>
</blockquote>
<blockquote>
<p>重要的是要记住，在 webpack 配置中定义 rules 时，要定义在 <code>module.rules</code> 而不是 <code>rules</code> 中。为了使你受益于此，如果没有按照正确方式去做，webpack 会给出警告。</p>
</blockquote>
<blockquote>
<p>请记住，使用正则表达式匹配文件时，你不要为它添加引号。也就是说，<code>/\.txt$/</code> 与 <code>&#39;/\.txt$/&#39;</code>/ <code>&quot;/\.txt$/&quot;</code> 不一样。前者指示 webpack 匹配任何以 .txt 结尾的文件，后者指示 webpack 匹配具有绝对路径 ‘.txt’ 的单个文件; 这可能不符合你的意图。</p>
</blockquote>
<p>在使用 loader 时，可以阅读 <a href="https://webpack.docschina.org/concepts/loaders" target="_blank" rel="noopener">loader 章节</a> 查看更深入的自定义配置。</p>
<h2 id="插件-plugin"><a href="#插件-plugin" class="headerlink" title="插件(plugin)"></a>插件(plugin)</h2><p>loader 用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。包括：打包优化，资源管理，注入环境变量。</p>
<blockquote>
<p><a href="https://webpack.docschina.org/api/plugins" target="_blank" rel="noopener">插件接口(plugin interface)</a> 功能极其强大，可以用来处理各种各样的任务。</p>
</blockquote>
<p>想要使用一个插件，你只需要 <code>require()</code> 它，然后把它添加到 <code>plugins</code> 数组中。多数插件可以通过选项(option)自定义。你也可以在一个配置文件中因为不同目的而多次使用同一个插件，这时需要通过使用 <code>new</code> 操作符来创建它的一个实例。</p>
<p><strong>webpack.config.js</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>); <span class="comment">// 通过 npm 安装</span></span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>); <span class="comment">// 用于访问内置插件</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123; <span class="attr">test</span>: <span class="regexp">/\.txt$/</span>, <span class="attr">use</span>: <span class="string">'raw-loader'</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;<span class="attr">template</span>: <span class="string">'./src/index.html'</span>&#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，<code>html-webpack-plugin</code> 为应用程序生成 HTML 一个文件，并自动注入所有生成的 bundle。</p>
<blockquote>
<p>webpack 提供许多开箱可用的插件！查阅 <a href="https://webpack.docschina.org/plugins" target="_blank" rel="noopener">插件列表</a> 获取更多。</p>
</blockquote>
<p>在 webpack 配置中使用插件是简单直接的，然而也有很多值得我们进一步探讨的用例。<a href="https://webpack.docschina.org/concepts/plugins" target="_blank" rel="noopener">查看这里了解更多</a>。</p>
<h2 id="模式-mode"><a href="#模式-mode" class="headerlink" title="模式(mode)"></a>模式(mode)</h2><p>通过选择 <code>development</code>, <code>production</code> 或 <code>none</code> 之中的一个，来设置 <code>mode</code> 参数，你可以启用 webpack 内置在相应环境下的优化。其默认值为 <code>production</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">'production'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>查看 <a href="https://webpack.docschina.org/concepts/mode" target="_blank" rel="noopener">模式配置</a> 章节了解其详细内容和每个值所作的优化。</p>
<h2 id="浏览器兼容性-browser-compatibility"><a href="#浏览器兼容性-browser-compatibility" class="headerlink" title="浏览器兼容性(browser compatibility)"></a>浏览器兼容性(browser compatibility)</h2><p>webpack 支持所有符合 <a href="https://kangax.github.io/compat-table/es5/" target="_blank" rel="noopener">ES5 标准</a> 的浏览器（不支持 IE8 及以下版本）。webpack 的 <code>import()</code> 和 <code>require.ensure()</code> 需要 <code>Promise</code>。如果你想要支持旧版本浏览器，在使用这些表达式之前，还需要 <a href="https://webpack.docschina.org/guides/shimming/" target="_blank" rel="noopener">提前加载 polyfill</a>。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Babel</tag>
      </tags>
  </entry>
  <entry>
    <title>开源项目领课试玩</title>
    <url>/2020/04/30/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E9%A2%86%E8%AF%BE%E8%AF%95%E7%8E%A9/</url>
    <content><![CDATA[<p><strong>启动顺序：注册中心 → 配置中心→ 模块工程 → 定时器 → 网关工程</strong> </p>
<p>1.启动注册中心</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">com.roncoo.education.server.eureka.ServerEurekaApplication</span><br></pre></td></tr></table></figure>

<p>2.启动配置中心</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">com.roncoo.education.service.config.ServerConfigApplication</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>单向链表</title>
    <url>/2020/04/27/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="链表-Linked-List-介绍"><a href="#链表-Linked-List-介绍" class="headerlink" title="链表(Linked List)介绍"></a>链表(Linked List)介绍</h2><p>链表是有序的列表，但是它在内存中是存储如下</p>
<p><img src="https://note.youdao.com/yws/public/resource/00fa35539db96d9324497e53f7f7bab4/xmlnote/250B078E564E4853A677EC5EA904AD41/5151" alt="链表"></p>
<p>小结:</p>
<p>1)链表是以节点的方式来存储,是链式存储</p>
<p>2)每个节点包含 data 域， next 域：指向下一个节点.</p>
<p>3)如图：发现链表的<strong>各个节点不一定是连续存储</strong>.</p>
<p>链表分带头节点的链表和没有头节点的链表，根据实际的需求来确定</p>
<h2 id="单链表介绍"><a href="#单链表介绍" class="headerlink" title="单链表介绍"></a>单链表介绍</h2><p>单链表(带头结点) 逻辑结构示意图如下</p>
<p><img src="https://note.youdao.com/yws/public/resource/00fa35539db96d9324497e53f7f7bab4/xmlnote/B8A4B86BC6844789AE8953161922B3F3/5154" alt="单链表"></p>
<h2 id="单链表的应用实例"><a href="#单链表的应用实例" class="headerlink" title="单链表的应用实例"></a>单链表的应用实例</h2><p>使用带head头的<strong>单向链表</strong>实现 –水浒英雄排行榜管理</p>
<p>1)完成对英雄人物的<strong>增删改查</strong>操作， 注: 删除和修改,查找可以考虑学员独立完成，也可带学员完成</p>
<p>2)第一种方法在添加英雄时，直接添加到链表的尾部</p>
<p>第二种方式在添加英雄时，根据排名将英雄插入到指定位置 (如果有这个排名，则添加失败，并给出提示)</p>
]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>队列-数组模拟队列</title>
    <url>/2020/04/27/%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h2 id="队列介绍"><a href="#队列介绍" class="headerlink" title="队列介绍"></a>队列介绍</h2><p>​    队列是一个有序列表，可以用<strong>数组</strong>或是<strong>链表</strong>来实现。</p>
<p>​    遵循<strong>先入先出</strong>的原则。即：先存入队列的数据，要先取出。后存入的要后取出</p>
<p>​    示意图：(使用数组模拟队列示意图)</p>
<p><img src="https://note.youdao.com/yws/public/resource/d979a0c95522a509f98b585257e09737/xmlnote/5D194BCE0D1E4BAEB0008D787140D194/5145" alt="队列"></p>
<h2 id="数组模拟队列"><a href="#数组模拟队列" class="headerlink" title="数组模拟队列"></a><strong>数组模拟队列</strong></h2><p>​    队列本身是有序列表，若使用数组的结构来存储队列的数据，则队列数组的声明如下图, 其中 <strong>maxSize</strong> 是该队列的最大容量。</p>
<p>​    因为队列的输出、输入是分别从前后端来处理，因此需要两个变量<strong>front</strong>及<strong>rear</strong>分别记录队列前后端的下标，front 会随着数据输出而改变，而 rear则是随着数据输入而改变。</p>
<p>​    当我们将数据存入队列时称为”addQueue”，addQueue 的处理需要有两个步骤：</p>
<p>思路分析</p>
<p>1)将尾指针往后移：rear+1 , 当front == rear 【空】</p>
<p>2)若尾指针 rear 小于队列的最大下标 maxSize-1，则将数据存入 rear所指的数组元素中，否则无法存入数据。 rear == maxSize - 1[队列满]</p>
<blockquote>
<p><strong>1.rear 是队列最后[含]</strong></p>
<p><strong>2.front 是队列最前元素[不含]</strong></p>
</blockquote>
<p><strong>数组模拟队列</strong></p>
<blockquote>
<p>出队列操作getQueue</p>
<p>显示队列的情况showQueue</p>
<p>查看队列头元素headQueue</p>
<p>退出系统exit</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.doubledumbao.sparsearray.queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayQueueDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">char</span> key = <span class="string">' '</span>;<span class="comment">//接收用户输入</span></span><br><span class="line">        ArrayQueue arrayQueue = <span class="keyword">new</span> ArrayQueue(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">boolean</span> loop = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(loop)&#123;</span><br><span class="line">            System.out.println(<span class="string">"a(add):添加数据到队列"</span>);</span><br><span class="line">            System.out.println(<span class="string">"s(show):显示队列"</span>);</span><br><span class="line">            System.out.println(<span class="string">"e(exit):退出程序"</span>);</span><br><span class="line">            System.out.println(<span class="string">"g(get):从队列取出数据"</span>);</span><br><span class="line">            System.out.println(<span class="string">"h(head):查看队列头的数据"</span>);</span><br><span class="line">            key = scanner.next().charAt(<span class="number">0</span>);<span class="comment">//接收一个字符</span></span><br><span class="line">            <span class="keyword">switch</span> (key)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'a'</span>:</span><br><span class="line">                    System.out.println(<span class="string">"输入一个数："</span>);</span><br><span class="line">                    <span class="keyword">int</span> val = scanner.nextInt();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        arrayQueue.addQueue(val);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'s'</span>:</span><br><span class="line">                    arrayQueue.showQueue();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'g'</span>:</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(arrayQueue.getQueue());</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'h'</span>:</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(arrayQueue.headQueue());</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'e'</span>:</span><br><span class="line">                    loop = <span class="keyword">false</span>;</span><br><span class="line">                    scanner.close();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数组模拟队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayQueue</span></span>&#123;</span><br><span class="line">    <span class="comment">//队列容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize;</span><br><span class="line">    <span class="comment">//队列前端的下标</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> front;</span><br><span class="line">    <span class="comment">//队列后端的下标</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> rear;</span><br><span class="line">    <span class="comment">//存储数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayQueue</span><span class="params">(<span class="keyword">int</span> maxSize)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">        <span class="keyword">this</span>.front = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">this</span>.rear= -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">this</span>.arr = <span class="keyword">new</span> <span class="keyword">int</span>[maxSize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断队列是否满了</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">ifFull</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rear == maxSize -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断队列是否为空</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rear == front;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向队列中添加数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addQueue</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ifFull())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"队列已满，无法添加数据"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        rear++;</span><br><span class="line">        <span class="keyword">this</span>.arr[rear] = a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从队列中取出一个数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"队列为空，无法取出数据"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        front ++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.arr[front];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 展示队列数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">            System.out.println(<span class="string">"队列为空"</span>);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.arr.length; i++) &#123;</span><br><span class="line">            System.out.printf(<span class="string">"arr[%d] = %d \n"</span>,i,arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查看队列头</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">headQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"队列为空"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.arr[front+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>问题分析并优化</strong></p>
<p> 1) 目前数组使用一次就不能用， 没有达到复用的效果<br> 2) 将这个数组使用算法，改进成一个环形的队列 取模:%</p>
<hr>
<h2 id="数组模拟环形队列"><a href="#数组模拟环形队列" class="headerlink" title="数组模拟环形队列"></a><strong>数组模拟环形队列</strong></h2><p>对前面的数组模拟队列的优化，充分利用数组. 因此将数组看做是一个环形的。(通过取模的方式来实现即可)</p>
<p>分析说明：</p>
<p>1)尾索引的下一个为头索引时表示队列满，即将队列容量<strong>空出一个</strong>作为约定,这个在做判断队列满的<br> 时候需要注意 (rear + 1) % maxSize == front 满]</p>
<p>2)rear == front [空]</p>
<p><img src="https://note.youdao.com/yws/public/resource/d979a0c95522a509f98b585257e09737/xmlnote/A53FC9CA7EF14CAA81A1B9B61DD4763A/5147" alt="使用数组模拟唤醒队列的思路分析"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.doubledumbao.sparsearray.queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CircleArrayQueueDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">char</span> key = <span class="string">' '</span>;<span class="comment">//接收用户输入</span></span><br><span class="line">        CircleArrayQueue arrayQueue = <span class="keyword">new</span> CircleArrayQueue(<span class="number">4</span>);</span><br><span class="line">        <span class="keyword">boolean</span> loop = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (loop) &#123;</span><br><span class="line">            System.out.println(<span class="string">"a(add):添加数据到队列"</span>);</span><br><span class="line">            System.out.println(<span class="string">"s(show):显示队列"</span>);</span><br><span class="line">            System.out.println(<span class="string">"e(exit):退出程序"</span>);</span><br><span class="line">            System.out.println(<span class="string">"g(get):从队列取出数据"</span>);</span><br><span class="line">            System.out.println(<span class="string">"h(head):查看队列头的数据"</span>);</span><br><span class="line">            key = scanner.next().charAt(<span class="number">0</span>);<span class="comment">//接收一个字符</span></span><br><span class="line">            <span class="keyword">switch</span> (key) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'a'</span>:</span><br><span class="line">                    System.out.println(<span class="string">"输入一个数："</span>);</span><br><span class="line">                    <span class="keyword">int</span> val = scanner.nextInt();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        arrayQueue.addQueue(val);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'s'</span>:</span><br><span class="line">                    arrayQueue.showQueue();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'g'</span>:</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(arrayQueue.getQueue());</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'h'</span>:</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(arrayQueue.headQueue());</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'e'</span>:</span><br><span class="line">                    loop = <span class="keyword">false</span>;</span><br><span class="line">                    scanner.close();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数组模拟环形队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CircleArrayQueue</span> </span>&#123;</span><br><span class="line">    <span class="comment">//队列容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize;</span><br><span class="line">    <span class="comment">//队列前端的下标</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> front;</span><br><span class="line">    <span class="comment">//队列后端的下标+1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> rear;</span><br><span class="line">    <span class="comment">//存储数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CircleArrayQueue</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">        <span class="keyword">this</span>.arr = <span class="keyword">new</span> <span class="keyword">int</span>[maxSize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断队列是否满了</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">ifFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> front == (rear + <span class="number">1</span>) % maxSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断队列是否为空</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rear == front;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向队列中添加数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addQueue</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ifFull()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"队列已满，无法添加数据"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//直接将数据加入</span></span><br><span class="line">        <span class="keyword">this</span>.arr[rear] = a;</span><br><span class="line">        <span class="comment">//将rear后移，这里必须考虑取模</span></span><br><span class="line">        rear = (rear + <span class="number">1</span>) % maxSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从队列中取出一个数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"队列为空，无法取出数据"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里需要分析出front是指向队列的第一个元素</span></span><br><span class="line">        <span class="comment">//1。先把front对应的值保留到一个临时变量</span></span><br><span class="line">        <span class="comment">//2。将front后移，考虑取模</span></span><br><span class="line">        <span class="comment">//3。把临时保存的变量返回</span></span><br><span class="line">        <span class="keyword">int</span> value = arr[front];</span><br><span class="line">        front = (front+<span class="number">1</span>) % maxSize;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 展示队列数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"队列为空"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//思路：从front开始遍历，遍历多少个元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = front; i &lt; front+size(); i++) &#123;</span><br><span class="line">            System.out.printf(<span class="string">"arr[%d] = %d \n"</span>, i%maxSize, arr[i%maxSize]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查看队列头</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">headQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"队列为空"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.arr[front];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取队列真实容量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (rear+maxSize-front)%maxSize;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>学习数据结构和算法的网站</title>
    <url>/2020/04/27/%E5%AD%A6%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E7%9A%84%E7%BD%91%E7%AB%99/</url>
    <content><![CDATA[<h1 id="数据结构和算法可视化网站："><a href="#数据结构和算法可视化网站：" class="headerlink" title="数据结构和算法可视化网站："></a>数据结构和算法可视化网站：</h1><h6 id="数据结构和算法动态可视化-https-visualgo-net-zh"><a href="#数据结构和算法动态可视化-https-visualgo-net-zh" class="headerlink" title="数据结构和算法动态可视化 https://visualgo.net/zh"></a>数据结构和算法动态可视化 <a href="https://visualgo.net/zh" target="_blank" rel="noopener">https://visualgo.net/zh</a></h6><h6 id="Data-Structure-Visualizations-https-www-cs-usfca-edu-galles-visualization-Algorithms-html"><a href="#Data-Structure-Visualizations-https-www-cs-usfca-edu-galles-visualization-Algorithms-html" class="headerlink" title="Data Structure Visualizations https://www.cs.usfca.edu/~galles/visualization/Algorithms.html"></a>Data Structure Visualizations <a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html" target="_blank" rel="noopener">https://www.cs.usfca.edu/~galles/visualization/Algorithms.html</a></h6><h6 id="尚硅谷Java数据结构与java算法，韩顺平数据结构与算法-https-www-bilibili-com-video-BV1E4411H73v"><a href="#尚硅谷Java数据结构与java算法，韩顺平数据结构与算法-https-www-bilibili-com-video-BV1E4411H73v" class="headerlink" title="尚硅谷Java数据结构与java算法，韩顺平数据结构与算法 https://www.bilibili.com/video/BV1E4411H73v"></a>尚硅谷Java数据结构与java算法，韩顺平数据结构与算法 <a href="https://www.bilibili.com/video/BV1E4411H73v" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1E4411H73v</a></h6>]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>稀疏sparsearray数组</title>
    <url>/2020/04/27/%E7%A8%80%E7%96%8Fsparsearray%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p><strong>先看一个实际的需求</strong></p>
<p>编写的五子棋程序中，有<strong>存盘退出</strong>和续上盘的功能。</p>
<p><img src="https://note.youdao.com/yws/public/resource/40270b32c0f73e2f81cca917c61dfdaf/xmlnote/5353EB007E384DACB2BE013B2B6FA800/5124" alt="wuziq"></p>
<p><strong>分析问题:</strong></p>
<p>因为该二维数组的很多值是默认值0, 因此记录了很多没有意义的数据.-&gt;稀疏数组。</p>
<p><strong>基本介绍</strong></p>
<p>当一个数组中大部分元素为０，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。</p>
<p>稀疏数组的处理方法是:</p>
<p>1)记录数组一共有几行几列，有多少个不同的值</p>
<p>2)把具有不同值的元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模</p>
<p><strong>稀疏数组和二维数组转换思路</strong></p>
<p><img src="https://note.youdao.com/yws/public/resource/40270b32c0f73e2f81cca917c61dfdaf/xmlnote/619DAE9207EB44C4ABC16E296FC54B98/5135" alt="3"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.doubledumbao.sparsearray;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二维数组和稀疏数组互转</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SparseArray</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 0: 表示没有棋子， 1 表示 黑子 2 表蓝子</span></span><br><span class="line">        <span class="keyword">int</span>[][] doubleDimensionalArray = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line">        doubleDimensionalArray[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        doubleDimensionalArray[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">2</span>;</span><br><span class="line">        doubleDimensionalArray[<span class="number">4</span>][<span class="number">7</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"二维数组："</span>);</span><br><span class="line">        <span class="comment">//实际数据个数</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] arr : doubleDimensionalArray) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> data : arr) &#123;</span><br><span class="line">                <span class="keyword">if</span>(data!=<span class="number">0</span>)&#123;</span><br><span class="line">                    sum ++;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.printf(<span class="string">"%d\t"</span>, data);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"--------------------"</span>);</span><br><span class="line">        System.out.println(<span class="string">"将二维数组转成稀疏数组"</span>);</span><br><span class="line">        System.out.println(<span class="string">"实际数据个数："</span>+sum);</span><br><span class="line">        <span class="comment">//定义稀疏数组</span></span><br><span class="line">        <span class="keyword">int</span>[][] sparseArr = <span class="keyword">new</span> <span class="keyword">int</span> [sum+<span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">11</span>;</span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">11</span>;</span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">2</span>] = sum;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; doubleDimensionalArray.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; doubleDimensionalArray[i].length; j++) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(doubleDimensionalArray[i][j]!=<span class="number">0</span>)&#123;</span><br><span class="line">                    count ++;</span><br><span class="line">                    sparseArr[count][<span class="number">0</span>] = i;</span><br><span class="line">                    sparseArr[count][<span class="number">1</span>] = j;</span><br><span class="line">                    sparseArr[count][<span class="number">2</span>] = doubleDimensionalArray[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将稀疏数组输出到文件中</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"map.data"</span>);</span><br><span class="line">        writeObjectToFile(sparseArr,file);</span><br><span class="line">        <span class="comment">//从文件中读取稀疏数组</span></span><br><span class="line">        <span class="keyword">int</span>[][] sparseArr1 = (<span class="keyword">int</span>[][]) readFileToObject(file);</span><br><span class="line">        System.out.println(<span class="string">"打印稀疏数组："</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sparseArr1.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; sparseArr1[i].length; j++) &#123;</span><br><span class="line">                System.out.printf(<span class="string">"%d\t"</span>,sparseArr1[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"将稀疏数组转成二维数组"</span>);</span><br><span class="line">        <span class="comment">//1.读取稀疏数组的第一行，创建二维数组</span></span><br><span class="line">        <span class="keyword">int</span>[][] arr2 = <span class="keyword">new</span> <span class="keyword">int</span>[sparseArr1[<span class="number">0</span>][<span class="number">0</span>]][sparseArr1[<span class="number">0</span>][<span class="number">1</span>]];</span><br><span class="line">        <span class="comment">//2. 在读取稀疏数组后几行的数据(从第二行开始)，并赋给 原始的二维数组 即可</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;sparseArr1.length;i++)&#123;</span><br><span class="line">            arr2[sparseArr1[i][<span class="number">0</span>]][sparseArr1[i][<span class="number">1</span>]] = sparseArr1[i][<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"二维数组："</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] arr : arr2) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> data : arr) &#123;</span><br><span class="line">                System.out.printf(<span class="string">"%d\t"</span>, data);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从文件中读出稀疏数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">readFileToObject</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">        InputStream inputStream = <span class="keyword">null</span>;</span><br><span class="line">        ObjectInputStream objectInputStream = <span class="keyword">null</span>;</span><br><span class="line">        Object readObject = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            inputStream = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">            objectInputStream = <span class="keyword">new</span> ObjectInputStream(inputStream);</span><br><span class="line">            readObject = objectInputStream.readObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(objectInputStream!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    objectInputStream.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(inputStream!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    inputStream.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> readObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将数组写入到文件中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> objcet</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeObjectToFile</span><span class="params">(Object objcet,File file)</span></span>&#123;</span><br><span class="line">        OutputStream outputStream = <span class="keyword">null</span>;</span><br><span class="line">        ObjectOutputStream objectOutputStream = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            outputStream = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">            objectOutputStream = <span class="keyword">new</span> ObjectOutputStream(outputStream);</span><br><span class="line">            objectOutputStream.writeObject(objcet);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(outputStream!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    outputStream.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(objectOutputStream!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    objectOutputStream.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack-学习笔记</title>
    <url>/2020/04/26/webpack-study/</url>
    <content><![CDATA[<h1 id="webpack学习笔记"><a href="#webpack学习笔记" class="headerlink" title="webpack学习笔记"></a>webpack学习笔记</h1><p>webpack官网：<a href="https://webpack.docschina.org/concepts/" target="_blank" rel="noopener">https://webpack.docschina.org/concepts/</a></p>
<h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h2><p>本质上，<strong>webpack</strong> 是一个现代 JavaScript 应用程序的<em>静态模块打包工具</em>。当 webpack 处理应用程序时，它会在内部构建一个 <a href="https://webpack.docschina.org/concepts/dependency-graph/" target="_blank" rel="noopener">依赖图(dependency graph)</a>，此依赖图会映射项目所需的每个模块，并生成一个或多个 <em>bundle</em>。</p>
<h2 id="2-安装"><a href="#2-安装" class="headerlink" title="2.安装"></a>2.安装</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install webpack -g</span><br><span class="line">npm install webpack-cli -g</span><br><span class="line"><span class="comment">#测试安装成功</span></span><br><span class="line">webpack -v</span><br><span class="line">webpack-cli -v</span><br></pre></td></tr></table></figure>

<h2 id="3-使用webpack"><a href="#3-使用webpack" class="headerlink" title="3.使用webpack"></a>3.使用webpack</h2><p>3.1 创建项目webpack-study</p>
<p>3.2创建一个名为modules的目录，用于放置JS模块等资源文件</p>
<p>3.3在modules下创建模块文件，如hello.js，用于编写JS模块相关代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 暴露一个方法</span></span><br><span class="line">exports.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">document</span>.write(<span class="string">"&lt;h1&gt;webpack study&lt;/h1&gt;"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.4在modules下创建一个名为main.js的入口文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> hello = <span class="built_in">require</span>(<span class="string">"./hello"</span>);</span><br><span class="line">hello.sayHi();</span><br></pre></td></tr></table></figure>

<p>3.5在项目目录下创建webpack.config.js配置文件，使用webpack命令打包</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports=&#123;</span><br><span class="line">	entry:<span class="string">'./modules/main.js'</span>,</span><br><span class="line">	output: &#123;</span><br><span class="line">		filename:<span class="string">'./js/bundle.js'</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.6在项目目录下，执行命令webpack进行打包，项目目录下生成dist/js/bundle.js文件</p>
<p>3.7在项目目录下，新建index.html,内容如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"dist/js/bundle.js"</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>3.8打开浏览器，查看效果。</p>
<p><strong><em>项目目录结构如下：</em></strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">webpack-study</span><br><span class="line">├── dist</span><br><span class="line">│   └── js</span><br><span class="line">│       └── bundle.js</span><br><span class="line">├── index.html</span><br><span class="line">├── modules</span><br><span class="line">│   ├── hello.js</span><br><span class="line">│   └── main.js</span><br><span class="line">└── webpack.config.js</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>JUC学习笔记</title>
    <url>/2020/04/25/JUC/</url>
    <content><![CDATA[<h1 id="JUC学习笔记"><a href="#JUC学习笔记" class="headerlink" title="JUC学习笔记"></a>JUC学习笔记</h1><h2 id="1-什么是JUC"><a href="#1-什么是JUC" class="headerlink" title="1.什么是JUC"></a>1.什么是JUC</h2><p>源码+官方文档</p>
<p><img src="JUC/image-20200422083034285.png" alt="image-20200422083034285"></p>
<p>JUC ==&gt; java util concurrent</p>
<h2 id="2-线程和进程"><a href="#2-线程和进程" class="headerlink" title="2.线程和进程"></a>2.线程和进程</h2><p>进程：一个程序，QQ.exe Music.exe程序的集合</p>
<p>线程：Typora 写字、保存</p>
<blockquote>
<p>并发、并行</p>
</blockquote>
<p>并发编程：并发、并行</p>
<p>并发（多线程操作同一个资源）</p>
<ul>
<li>CPU一核，模拟出多条线程，天下武功，唯快不破，快速交替</li>
</ul>
<p>并行（多个人一起行走）</p>
<ul>
<li>CPU多核，多个线程可以同时执行；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test1 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;CPU核数</span><br><span class="line">        &#x2F;&#x2F;Returns the number of processors available to the Java virtual machine.</span><br><span class="line">        System.out.println(Runtime.getRuntime().availableProcessors());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="线程有几种状态"><a href="#线程有几种状态" class="headerlink" title="线程有几种状态"></a>线程有几种状态</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public enum State &#123;</span><br><span class="line">        &#x2F;**</span><br><span class="line">         * Thread state for a thread which has not yet started.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        NEW,</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * Thread state for a runnable thread.  A thread in the runnable</span><br><span class="line">         * state is executing in the Java virtual machine but it may</span><br><span class="line">         * be waiting for other resources from the operating system</span><br><span class="line">         * such as processor.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        RUNNABLE,</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * Thread state for a thread blocked waiting for a monitor lock.</span><br><span class="line">         * A thread in the blocked state is waiting for a monitor lock</span><br><span class="line">         * to enter a synchronized block&#x2F;method or</span><br><span class="line">         * reenter a synchronized block&#x2F;method after calling</span><br><span class="line">         * &#123;@link Object#wait() Object.wait&#125;.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        BLOCKED,</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * Thread state for a waiting thread.</span><br><span class="line">         * A thread is in the waiting state due to calling one of the</span><br><span class="line">         * following methods:</span><br><span class="line">         * &lt;ul&gt;</span><br><span class="line">         *   &lt;li&gt;&#123;@link Object#wait() Object.wait&#125; with no timeout&lt;&#x2F;li&gt;</span><br><span class="line">         *   &lt;li&gt;&#123;@link #join() Thread.join&#125; with no timeout&lt;&#x2F;li&gt;</span><br><span class="line">         *   &lt;li&gt;&#123;@link LockSupport#park() LockSupport.park&#125;&lt;&#x2F;li&gt;</span><br><span class="line">         * &lt;&#x2F;ul&gt;</span><br><span class="line">         *</span><br><span class="line">         * &lt;p&gt;A thread in the waiting state is waiting for another thread to</span><br><span class="line">         * perform a particular action.</span><br><span class="line">         *</span><br><span class="line">         * For example, a thread that has called &lt;tt&gt;Object.wait()&lt;&#x2F;tt&gt;</span><br><span class="line">         * on an object is waiting for another thread to call</span><br><span class="line">         * &lt;tt&gt;Object.notify()&lt;&#x2F;tt&gt; or &lt;tt&gt;Object.notifyAll()&lt;&#x2F;tt&gt; on</span><br><span class="line">         * that object. A thread that has called &lt;tt&gt;Thread.join()&lt;&#x2F;tt&gt;</span><br><span class="line">         * is waiting for a specified thread to terminate.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        WAITING,</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * Thread state for a waiting thread with a specified waiting time.</span><br><span class="line">         * A thread is in the timed waiting state due to calling one of</span><br><span class="line">         * the following methods with a specified positive waiting time:</span><br><span class="line">         * &lt;ul&gt;</span><br><span class="line">         *   &lt;li&gt;&#123;@link #sleep Thread.sleep&#125;&lt;&#x2F;li&gt;</span><br><span class="line">         *   &lt;li&gt;&#123;@link Object#wait(long) Object.wait&#125; with timeout&lt;&#x2F;li&gt;</span><br><span class="line">         *   &lt;li&gt;&#123;@link #join(long) Thread.join&#125; with timeout&lt;&#x2F;li&gt;</span><br><span class="line">         *   &lt;li&gt;&#123;@link LockSupport#parkNanos LockSupport.parkNanos&#125;&lt;&#x2F;li&gt;</span><br><span class="line">         *   &lt;li&gt;&#123;@link LockSupport#parkUntil LockSupport.parkUntil&#125;&lt;&#x2F;li&gt;</span><br><span class="line">         * &lt;&#x2F;ul&gt;</span><br><span class="line">         *&#x2F;</span><br><span class="line">        TIMED_WAITING,</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * Thread state for a terminated thread.</span><br><span class="line">         * The thread has completed execution.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        TERMINATED;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="wait-sleep区别"><a href="#wait-sleep区别" class="headerlink" title="wait/sleep区别"></a>wait/sleep区别</h4><p>1.来自不同的类</p>
<p>wait ==&gt; Object</p>
<p>sleep ==&gt; Thread</p>
<p>2.关于锁的释放</p>
<p>wait会释放锁，sleep睡觉了，抱着锁睡觉，不会释放。</p>
<p>3.使用的范围是不同的</p>
<p>wait:必须在同步代码块中</p>
<p>sleep：可以在任何地方睡觉</p>
<p>4.是否需要捕获异常</p>
<p>wait 不需要捕获异常</p>
<p>sleep必须要捕获异常</p>
<h2 id="3-Lock锁-（重点）"><a href="#3-Lock锁-（重点）" class="headerlink" title="3.Lock锁 （重点）"></a>3.Lock锁 （重点）</h2><p>售票</p>
<p>传统的synchronized写法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class SaleTicketDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Ticket ticket &#x3D; new Ticket();</span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            for (int i &#x3D; 0; i &lt; 30; i++) &#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,&quot;A&quot;).start();</span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            for (int i &#x3D; 0; i &lt; 30; i++) &#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,&quot;B&quot;).start();</span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            for (int i &#x3D; 0; i &lt; 30; i++) &#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,&quot;C&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Ticket&#123;</span><br><span class="line">    private int count &#x3D; 50;</span><br><span class="line"> &#x2F;&#x2F;synchronized本质：队列，排队</span><br><span class="line">    public synchronized void sale()&#123;</span><br><span class="line">        if(count &gt; 0)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot;售出了编号为&quot;+ count-- + &quot;张票，还剩&quot;+count+&quot;张票！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Lock：</p>
<p><img src="JUC/image-20200422130054463.png" alt="image-20200422130054463"></p>
<p><img src="JUC/image-20200422130134800.png" alt="image-20200422130134800"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class SaleTicketDemo2 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Ticket2 ticket &#x3D; new Ticket2();</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            for (int i &#x3D; 0; i &lt; 30; i++)</span><br><span class="line">                ticket.sale();</span><br><span class="line">        &#125;, &quot;A&quot;).start();</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            for (int i &#x3D; 0; i &lt; 30; i++) &#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;B&quot;).start();</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            for (int i &#x3D; 0; i &lt; 30; i++) &#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;C&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Ticket2 &#123;</span><br><span class="line">    private int count &#x3D; 50;</span><br><span class="line"></span><br><span class="line">    Lock lock &#x3D; new ReentrantLock();</span><br><span class="line"></span><br><span class="line">    public void sale() &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            if (count &gt; 0) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot;售出了编号为&quot; + count-- + &quot;张票，还剩&quot; + count + &quot;张票！&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Synchronized和Lock区别"><a href="#Synchronized和Lock区别" class="headerlink" title="Synchronized和Lock区别"></a>Synchronized和Lock区别</h4><p>1.Synchronized 内置的Java关键字，Lock是一个Java类</p>
<p>2.Synchronized无法判断获取锁的状态，Lock可以判断是否获取到了锁</p>
<p>3.Synchronized会自动释放锁，Lock必须要手动释放锁！如果不释放锁，死锁</p>
<p>4.Synchronized线程1（获得锁，阻塞）、线程2（等待，傻傻的等）；Lock锁就不一定会等待下去；</p>
<p>5.Synchronized可重入锁，不可以中断的，非公平；Lock，可重入锁，可以判断锁，可以自己设置。</p>
<p>6.Synchronized适合锁少量的代码同步问题；Lock适合锁大量的代码。</p>
<h4 id="锁是什么，如何判断锁的是谁"><a href="#锁是什么，如何判断锁的是谁" class="headerlink" title="锁是什么，如何判断锁的是谁"></a>锁是什么，如何判断锁的是谁</h4><h2 id="4-生产者和消费者问题"><a href="#4-生产者和消费者问题" class="headerlink" title="4.生产者和消费者问题"></a>4.生产者和消费者问题</h2><p><img src="JUC/image-20200422134451133.png" alt="image-20200422134451133"></p>
<p>有问题的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.dumbao.demo01;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;生产者和消费者</span><br><span class="line">public class A &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Data data &#x3D; new Data();</span><br><span class="line">        &#x2F;&#x2F;线程A +1操作</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">                    data.increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;A&quot;).start();</span><br><span class="line">        &#x2F;&#x2F;线程B -1操作</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">                    data.decrement();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;B&quot;).start();</span><br><span class="line">        &#x2F;&#x2F;线程C +1操作</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">                    data.increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;C&quot;).start();</span><br><span class="line">        &#x2F;&#x2F;线程D -1操作</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">                    data.decrement();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;D&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;口诀：判断等待，业务，通知</span><br><span class="line">class Data &#123;</span><br><span class="line">    private int number &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;+1</span><br><span class="line">    public synchronized void increment() throws InterruptedException &#123;</span><br><span class="line">        if (number !&#x3D; 0) &#123;</span><br><span class="line">            &#x2F;&#x2F;等待</span><br><span class="line">            this.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        number++;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot; &#x3D;&gt; &quot; + number);</span><br><span class="line">        &#x2F;&#x2F;通知其他线程我+1完毕了</span><br><span class="line">        this.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;-1</span><br><span class="line">    public synchronized void decrement() throws InterruptedException &#123;</span><br><span class="line">        if (number &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            &#x2F;&#x2F;等待；</span><br><span class="line">            this.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        number--;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot; &#x3D;&gt; &quot; + number);</span><br><span class="line">        &#x2F;&#x2F;通知其他线程我-1完成了</span><br><span class="line">        this.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：注意看，其中有A =&gt; 2，结果不符合预期。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A &#x3D;&gt; 1</span><br><span class="line">B &#x3D;&gt; 0</span><br><span class="line">A &#x3D;&gt; 1</span><br><span class="line">B &#x3D;&gt; 0</span><br><span class="line">A &#x3D;&gt; 1</span><br><span class="line">B &#x3D;&gt; 0</span><br><span class="line">A &#x3D;&gt; 1</span><br><span class="line">B &#x3D;&gt; 0</span><br><span class="line">A &#x3D;&gt; 1</span><br><span class="line">B &#x3D;&gt; 0</span><br><span class="line">A &#x3D;&gt; 1</span><br><span class="line">B &#x3D;&gt; 0</span><br><span class="line">C &#x3D;&gt; 1</span><br><span class="line">B &#x3D;&gt; 0</span><br><span class="line">A &#x3D;&gt; 1</span><br><span class="line">B &#x3D;&gt; 0</span><br><span class="line">C &#x3D;&gt; 1</span><br><span class="line">B &#x3D;&gt; 0</span><br><span class="line">A &#x3D;&gt; 1</span><br><span class="line">B &#x3D;&gt; 0</span><br><span class="line">C &#x3D;&gt; 1</span><br><span class="line">A &#x3D;&gt; 2</span><br><span class="line">D &#x3D;&gt; 1</span><br><span class="line">D &#x3D;&gt; 0</span><br><span class="line">A &#x3D;&gt; 1</span><br><span class="line">C &#x3D;&gt; 2</span><br><span class="line">D &#x3D;&gt; 1</span><br><span class="line">D &#x3D;&gt; 0</span><br><span class="line">C &#x3D;&gt; 1</span><br><span class="line">D &#x3D;&gt; 0</span><br><span class="line">C &#x3D;&gt; 1</span><br><span class="line">D &#x3D;&gt; 0</span><br><span class="line">C &#x3D;&gt; 1</span><br><span class="line">D &#x3D;&gt; 0</span><br><span class="line">C &#x3D;&gt; 1</span><br><span class="line">D &#x3D;&gt; 0</span><br><span class="line">C &#x3D;&gt; 1</span><br><span class="line">D &#x3D;&gt; 0</span><br><span class="line">C &#x3D;&gt; 1</span><br><span class="line">D &#x3D;&gt; 0</span><br></pre></td></tr></table></figure>

<p>修改后代码：</p>
<h4 id="Synchronized版的生产者消费者"><a href="#Synchronized版的生产者消费者" class="headerlink" title="Synchronized版的生产者消费者"></a>Synchronized版的生产者消费者</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;生产者和消费者</span><br><span class="line">public class A &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Data data &#x3D; new Data();</span><br><span class="line">        &#x2F;&#x2F;线程A +1操作</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">                    data.increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;A&quot;).start();</span><br><span class="line">        &#x2F;&#x2F;线程B -1操作</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">                    data.decrement();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;B&quot;).start();</span><br><span class="line">        &#x2F;&#x2F;线程C +1操作</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">                    data.increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;C&quot;).start();</span><br><span class="line">        &#x2F;&#x2F;线程D -1操作</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">                    data.decrement();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;D&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;口诀：判断等待，业务，通知</span><br><span class="line">class Data &#123;</span><br><span class="line">    private int number &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;+1</span><br><span class="line">    public synchronized void increment() throws InterruptedException &#123;</span><br><span class="line">        while (number !&#x3D; 0) &#123;</span><br><span class="line">            &#x2F;&#x2F;等待</span><br><span class="line">            this.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        number++;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot; &#x3D;&gt; &quot; + number);</span><br><span class="line">        &#x2F;&#x2F;通知其他线程我+1完毕了</span><br><span class="line">        this.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;-1</span><br><span class="line">    public synchronized void decrement() throws InterruptedException &#123;</span><br><span class="line">        while (number &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            &#x2F;&#x2F;等待；</span><br><span class="line">            this.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        number--;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot; &#x3D;&gt; &quot; + number);</span><br><span class="line">        &#x2F;&#x2F;通知其他线程我-1完成了</span><br><span class="line">        this.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A &#x3D;&gt; 1</span><br><span class="line">B &#x3D;&gt; 0</span><br><span class="line">A &#x3D;&gt; 1</span><br><span class="line">B &#x3D;&gt; 0</span><br><span class="line">A &#x3D;&gt; 1</span><br><span class="line">B &#x3D;&gt; 0</span><br><span class="line">A &#x3D;&gt; 1</span><br><span class="line">B &#x3D;&gt; 0</span><br><span class="line">A &#x3D;&gt; 1</span><br><span class="line">B &#x3D;&gt; 0</span><br><span class="line">C &#x3D;&gt; 1</span><br><span class="line">B &#x3D;&gt; 0</span><br><span class="line">A &#x3D;&gt; 1</span><br><span class="line">B &#x3D;&gt; 0</span><br><span class="line">C &#x3D;&gt; 1</span><br><span class="line">D &#x3D;&gt; 0</span><br><span class="line">A &#x3D;&gt; 1</span><br><span class="line">B &#x3D;&gt; 0</span><br><span class="line">C &#x3D;&gt; 1</span><br><span class="line">D &#x3D;&gt; 0</span><br><span class="line">A &#x3D;&gt; 1</span><br><span class="line">B &#x3D;&gt; 0</span><br><span class="line">C &#x3D;&gt; 1</span><br><span class="line">D &#x3D;&gt; 0</span><br><span class="line">A &#x3D;&gt; 1</span><br><span class="line">B &#x3D;&gt; 0</span><br><span class="line">C &#x3D;&gt; 1</span><br><span class="line">D &#x3D;&gt; 0</span><br><span class="line">A &#x3D;&gt; 1</span><br><span class="line">D &#x3D;&gt; 0</span><br><span class="line">C &#x3D;&gt; 1</span><br><span class="line">D &#x3D;&gt; 0</span><br><span class="line">C &#x3D;&gt; 1</span><br><span class="line">D &#x3D;&gt; 0</span><br><span class="line">C &#x3D;&gt; 1</span><br><span class="line">D &#x3D;&gt; 0</span><br><span class="line">C &#x3D;&gt; 1</span><br><span class="line">D &#x3D;&gt; 0</span><br><span class="line">C &#x3D;&gt; 1</span><br><span class="line">D &#x3D;&gt; 0</span><br></pre></td></tr></table></figure>

<h4 id="JUC版的生产者消费者"><a href="#JUC版的生产者消费者" class="headerlink" title="JUC版的生产者消费者"></a>JUC版的生产者消费者</h4><p><img src="JUC/image-20200422202335783.png" alt="image-20200422202335783"></p>
<p><img src="JUC/image-20200422202535979.png" alt="image-20200422202535979"></p>
<p><img src="JUC/image-20200422202841115.png" alt="image-20200422202841115"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * JUC版的生产者消费者</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class B&#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Data2 data &#x3D; new Data2();</span><br><span class="line">        &#x2F;&#x2F;线程A +1操作</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">                    data.increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;A&quot;).start();</span><br><span class="line">        &#x2F;&#x2F;线程B -1操作</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">                    data.decrement();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;B&quot;).start();</span><br><span class="line">        &#x2F;&#x2F;线程C +1操作</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">                    data.increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;C&quot;).start();</span><br><span class="line">        &#x2F;&#x2F;线程D -1操作</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">                    data.decrement();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;D&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;口诀：判断等待，业务，通知</span><br><span class="line">class Data2 &#123;</span><br><span class="line">    private int number &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    final Lock lock &#x3D; new ReentrantLock();</span><br><span class="line">    final Condition condition &#x3D; lock.newCondition();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;+1</span><br><span class="line">    public  void increment() throws InterruptedException &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            &#x2F;&#x2F;业务</span><br><span class="line">            while (number !&#x3D; 0) &#123;</span><br><span class="line">                &#x2F;&#x2F;等待</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            number++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot; &#x3D;&gt; &quot; + number);</span><br><span class="line">            &#x2F;&#x2F;通知其他线程我+1完毕了</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;-1</span><br><span class="line">    public  void decrement() throws InterruptedException &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            &#x2F;&#x2F;业务</span><br><span class="line">            while (number &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                &#x2F;&#x2F;等待；</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            number--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot; &#x3D;&gt; &quot; + number);</span><br><span class="line">            &#x2F;&#x2F;通知其他线程我-1完成了</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A &#x3D;&gt; 1</span><br><span class="line">B &#x3D;&gt; 0</span><br><span class="line">A &#x3D;&gt; 1</span><br><span class="line">B &#x3D;&gt; 0</span><br><span class="line">A &#x3D;&gt; 1</span><br><span class="line">B &#x3D;&gt; 0</span><br><span class="line">A &#x3D;&gt; 1</span><br><span class="line">B &#x3D;&gt; 0</span><br><span class="line">A &#x3D;&gt; 1</span><br><span class="line">D &#x3D;&gt; 0</span><br><span class="line">A &#x3D;&gt; 1</span><br><span class="line">D &#x3D;&gt; 0</span><br><span class="line">A &#x3D;&gt; 1</span><br><span class="line">D &#x3D;&gt; 0</span><br><span class="line">A &#x3D;&gt; 1</span><br><span class="line">D &#x3D;&gt; 0</span><br><span class="line">A &#x3D;&gt; 1</span><br><span class="line">D &#x3D;&gt; 0</span><br><span class="line">A &#x3D;&gt; 1</span><br><span class="line">D &#x3D;&gt; 0</span><br><span class="line">C &#x3D;&gt; 1</span><br><span class="line">D &#x3D;&gt; 0</span><br><span class="line">C &#x3D;&gt; 1</span><br><span class="line">D &#x3D;&gt; 0</span><br><span class="line">C &#x3D;&gt; 1</span><br><span class="line">D &#x3D;&gt; 0</span><br><span class="line">C &#x3D;&gt; 1</span><br><span class="line">D &#x3D;&gt; 0</span><br><span class="line">C &#x3D;&gt; 1</span><br><span class="line">B &#x3D;&gt; 0</span><br><span class="line">C &#x3D;&gt; 1</span><br><span class="line">B &#x3D;&gt; 0</span><br><span class="line">C &#x3D;&gt; 1</span><br><span class="line">B &#x3D;&gt; 0</span><br><span class="line">C &#x3D;&gt; 1</span><br><span class="line">B &#x3D;&gt; 0</span><br><span class="line">C &#x3D;&gt; 1</span><br><span class="line">B &#x3D;&gt; 0</span><br><span class="line">C &#x3D;&gt; 1</span><br><span class="line">B &#x3D;&gt; 0</span><br></pre></td></tr></table></figure>

<p><img src="JUC/image-20200422204051367.png" alt="image-20200422204051367"></p>
<p><strong>任何一个技术，绝对不是仅仅只是覆盖原来的技术，优势和补充。</strong></p>
<p><strong>Condition 精准的通知和唤醒线程</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.concurrent.locks.Condition;</span><br><span class="line">import java.util.concurrent.locks.Lock;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 精确唤醒</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class C &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Data3 data &#x3D; new Data3();</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">                data.printA();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,&quot;A&quot;).start();</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">                data.printB();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,&quot;B&quot;).start();</span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">                data.printC();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,&quot;C&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Data3 &#123;</span><br><span class="line"></span><br><span class="line">    final Lock lock &#x3D; new ReentrantLock();</span><br><span class="line">    Condition condition1 &#x3D; lock.newCondition();</span><br><span class="line">    Condition condition2 &#x3D; lock.newCondition();</span><br><span class="line">    Condition condition3 &#x3D; lock.newCondition();</span><br><span class="line">    int num &#x3D; 1;&#x2F;&#x2F;1 printA 2 printB 3 printC</span><br><span class="line"></span><br><span class="line">    public void printA() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            &#x2F;&#x2F;业务</span><br><span class="line">            while (num !&#x3D; 1) &#123;</span><br><span class="line">                condition1.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot; &#x3D; &gt; AAAAA&quot; );</span><br><span class="line">            num &#x3D; 2;</span><br><span class="line">            condition2.signal();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void printB() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            while (num !&#x3D; 2) &#123;</span><br><span class="line">                condition2.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot; &#x3D; &gt; BBBBB&quot; );</span><br><span class="line">            num &#x3D; 3;</span><br><span class="line">            condition3.signal();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void printC() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            while (num !&#x3D; 3) &#123;</span><br><span class="line">                condition3.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot; &#x3D; &gt; CCCCC&quot; );</span><br><span class="line">            num &#x3D; 1;</span><br><span class="line">            condition1.signal();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A &#x3D; &gt; AAAAA</span><br><span class="line">B &#x3D; &gt; BBBBB</span><br><span class="line">C &#x3D; &gt; CCCCC</span><br><span class="line">A &#x3D; &gt; AAAAA</span><br><span class="line">B &#x3D; &gt; BBBBB</span><br><span class="line">C &#x3D; &gt; CCCCC</span><br><span class="line">A &#x3D; &gt; AAAAA</span><br><span class="line">B &#x3D; &gt; BBBBB</span><br><span class="line">C &#x3D; &gt; CCCCC</span><br><span class="line">A &#x3D; &gt; AAAAA</span><br><span class="line">B &#x3D; &gt; BBBBB</span><br><span class="line">C &#x3D; &gt; CCCCC</span><br><span class="line">A &#x3D; &gt; AAAAA</span><br><span class="line">B &#x3D; &gt; BBBBB</span><br><span class="line">C &#x3D; &gt; CCCCC</span><br><span class="line">A &#x3D; &gt; AAAAA</span><br><span class="line">B &#x3D; &gt; BBBBB</span><br><span class="line">C &#x3D; &gt; CCCCC</span><br><span class="line">A &#x3D; &gt; AAAAA</span><br><span class="line">B &#x3D; &gt; BBBBB</span><br><span class="line">C &#x3D; &gt; CCCCC</span><br><span class="line">A &#x3D; &gt; AAAAA</span><br><span class="line">B &#x3D; &gt; BBBBB</span><br><span class="line">C &#x3D; &gt; CCCCC</span><br><span class="line">A &#x3D; &gt; AAAAA</span><br><span class="line">B &#x3D; &gt; BBBBB</span><br><span class="line">C &#x3D; &gt; CCCCC</span><br><span class="line">A &#x3D; &gt; AAAAA</span><br><span class="line">B &#x3D; &gt; BBBBB</span><br><span class="line">C &#x3D; &gt; CCCCC</span><br></pre></td></tr></table></figure>

<h2 id="5-8锁问题现象彻底了解锁"><a href="#5-8锁问题现象彻底了解锁" class="headerlink" title="5.8锁问题现象彻底了解锁"></a>5.8锁问题现象彻底了解锁</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">public class Test01 &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 1.先发短信，还是先打电话：答案：先发短信，原因锁定的是同一个对象phone</span><br><span class="line">     * @param args</span><br><span class="line">     *&#x2F;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Phone phone &#x3D; new Phone();</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            phone.sendSms();</span><br><span class="line">        &#125;,&quot;A&quot;).start();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(1);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            phone.call();</span><br><span class="line">        &#125;,&quot;B&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Phone &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 发短信</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public synchronized void sendSms() &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;发短信！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 打电话</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public synchronized void call() &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;打电话！&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A发短信！</span><br><span class="line">B打电话！</span><br><span class="line">public class Test01 &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * &#x2F;&#x2F;1.先发短信，还是先打电话：答案：先发短信，原因锁定的是同一个对象phone</span><br><span class="line">     * 2.发短信休眠4秒，先发短信，还是先打电话。答案：先发短信，原因锁定的是同一个对象phone</span><br><span class="line">     * @param args</span><br><span class="line">     *&#x2F;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Phone phone &#x3D; new Phone();</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            phone.sendSms();</span><br><span class="line">        &#125;,&quot;A&quot;).start();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(1);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            phone.call();</span><br><span class="line">        &#125;,&quot;B&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Phone &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 发短信</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public synchronized void sendSms() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(4);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;发短信！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 打电话</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public synchronized void call() &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;打电话！&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A发短信！</span><br><span class="line">B打电话！</span><br><span class="line">public class Test01 &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * &#x2F;&#x2F;1.先发短信，还是先打电话：答案：先发短信，原因锁定的是同一个对象phone</span><br><span class="line">     * &#x2F;&#x2F;2.发短信休眠4秒，先发短信，还是先打电话。答案：先发短信，原因锁定的是同一个对象phone</span><br><span class="line">     * 3.两个手机，先发短信，还是先打电话。答案：先打电话。原因是锁定的不同的phone对象</span><br><span class="line">     * @param args</span><br><span class="line">     *&#x2F;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Phone phone1 &#x3D; new Phone();</span><br><span class="line">        Phone phone2 &#x3D; new Phone();</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            phone1.sendSms();</span><br><span class="line">        &#125;,&quot;A&quot;).start();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(1);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            phone2.call();</span><br><span class="line">        &#125;,&quot;B&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Phone &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 发短信</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public synchronized void sendSms() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(4);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;发短信！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 打电话</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public synchronized void call() &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;打电话！&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">B打电话！</span><br><span class="line">A发短信！</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">public class Test01 &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * &#x2F;&#x2F;1.先发短信，还是先打电话：答案：先发短信，原因锁定的是同一个对象phone</span><br><span class="line">     * &#x2F;&#x2F;2.发短信休眠4秒，先发短信，还是先打电话。答案：先发短信，原因锁定的是同一个对象phone</span><br><span class="line">     * &#x2F;&#x2F;3.两个手机，先发短信，还是先打电话。答案：先打电话。原因是锁定的不同的phone对象</span><br><span class="line">     * 4.先打电话，还是先发短信，还是先说hello。答案：先说hello，原因：hello方法没有加锁。</span><br><span class="line">     * @param args</span><br><span class="line">     *&#x2F;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Phone phone &#x3D; new Phone();</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            phone.sendSms();</span><br><span class="line">        &#125;,&quot;A&quot;).start();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(1);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            phone.call();</span><br><span class="line">        &#125;,&quot;B&quot;).start();</span><br><span class="line"></span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            phone.hello();</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Phone &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 发短信</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public synchronized void sendSms() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(4);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;发短信！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 打电话</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public synchronized void call() &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;打电话！&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void hello()&#123;</span><br><span class="line">        System.out.println(&quot;hello!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hello!</span><br><span class="line">A发短信！</span><br><span class="line">B打电话！</span><br><span class="line">public class Test02 &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 5.先发短信，还是先打电话：答案：先发短信，原因锁定的是同一个Phone.class对象</span><br><span class="line">     * @param args</span><br><span class="line">     *&#x2F;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Phone1 phone &#x3D; new Phone1();</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            phone.sendSms();</span><br><span class="line">        &#125;,&quot;A&quot;).start();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(1);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            phone.call();</span><br><span class="line">        &#125;,&quot;B&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Phone1 &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 发短信</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static synchronized void sendSms() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(4);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;发短信！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 打电话</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static synchronized void call() &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;打电话！&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A发短信！</span><br><span class="line">B打电话！</span><br><span class="line">public class Test02 &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * &#x2F;&#x2F;5.先发短信，还是先打电话：答案：先发短信，原因锁定的是同一个Phone.class对象</span><br><span class="line">     * 6.先发短信，还是先打电话：答案：先发短信，原因锁定的是同一个Phone.class对象</span><br><span class="line">     * @param args</span><br><span class="line">     *&#x2F;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Phone1 phone1 &#x3D; new Phone1();</span><br><span class="line">        Phone1 phone2 &#x3D; new Phone1();</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            phone1.sendSms();</span><br><span class="line">        &#125;,&quot;A&quot;).start();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(1);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            phone2.call();</span><br><span class="line">        &#125;,&quot;B&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Phone1 &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 发短信</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static synchronized void sendSms() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(4);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;发短信！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 打电话</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static synchronized void call() &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;打电话！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">B打电话！</span><br><span class="line">A发短信！</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">public class Test03 &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 7.先发短信，还是先打电话：答案：先打电话，原因锁定的是两个不同的对象。</span><br><span class="line">     * @param args</span><br><span class="line">     *&#x2F;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Phone2 phone &#x3D; new Phone2();</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            phone.sendSms();</span><br><span class="line">        &#125;,&quot;A&quot;).start();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(1);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            phone.call();</span><br><span class="line">        &#125;,&quot;B&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Phone2 &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 发短信</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static synchronized void sendSms() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(4);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;发短信！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 打电话</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public synchronized void call() &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;打电话！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">B打电话！</span><br><span class="line">A发短信！</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">public class Test04 &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 8.先发短信，还是先打电话：答案：先打电话，原因锁定的是两个不同的对象。</span><br><span class="line">     * @param args</span><br><span class="line">     *&#x2F;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Phone3 phone1 &#x3D; new Phone3();</span><br><span class="line">        Phone3 phone2 &#x3D; new Phone3();</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            phone1.sendSms();</span><br><span class="line">        &#125;,&quot;A&quot;).start();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(1);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            phone2.call();</span><br><span class="line">        &#125;,&quot;B&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Phone3 &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 发短信</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static synchronized void sendSms() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(4);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;发短信！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 打电话</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public synchronized void call() &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;打电话！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">B打电话！</span><br><span class="line">A发短信！</span><br></pre></td></tr></table></figure>

<h2 id="6-线程安全的集合类型"><a href="#6-线程安全的集合类型" class="headerlink" title="6.线程安全的集合类型"></a>6.线程安全的集合类型</h2><h5 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">import java.util.concurrent.CopyOnWriteArrayList;</span><br><span class="line"></span><br><span class="line">public class TestList &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;        List&lt;String&gt; strings &#x3D; Arrays.asList(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;);</span><br><span class="line">&#x2F;&#x2F;        System.out.println(strings);</span><br><span class="line">&#x2F;&#x2F;        List&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;        for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">&#x2F;&#x2F;            &#x2F;&#x2F;ConcurrentModificationException异常</span><br><span class="line">&#x2F;&#x2F;            new Thread(() -&gt; &#123;</span><br><span class="line">&#x2F;&#x2F;                list.add(UUID.randomUUID().toString().substring(0,5));</span><br><span class="line">&#x2F;&#x2F;                System.out.println(list);</span><br><span class="line">&#x2F;&#x2F;            &#125;).start();</span><br><span class="line">&#x2F;&#x2F;        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 解决方案：</span><br><span class="line">         * 1.Vector</span><br><span class="line">         * 2.Collections.synchronizedList</span><br><span class="line">         * 3.CopyOnWriteArrayList</span><br><span class="line">         *&#x2F;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;Vector</span><br><span class="line">&#x2F;&#x2F;        List&lt;String&gt; list &#x3D; new Vector&lt;&gt;();</span><br><span class="line">&#x2F;&#x2F;        for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">&#x2F;&#x2F;            new Thread(() -&gt; &#123;</span><br><span class="line">&#x2F;&#x2F;                list.add(UUID.randomUUID().toString().substring(0, 5));</span><br><span class="line">&#x2F;&#x2F;                System.out.println(Thread.currentThread().getName() + &quot;&#x3D;&#x3D;&gt; &quot; + list);</span><br><span class="line">&#x2F;&#x2F;            &#125;, String.valueOf(i)).start();</span><br><span class="line">&#x2F;&#x2F;        &#125;</span><br><span class="line">        &#x2F;&#x2F;2.Collections.synchronizedList</span><br><span class="line">&#x2F;&#x2F;        List&lt;String&gt; list &#x3D; Collections.synchronizedList(new ArrayList&lt;&gt;());</span><br><span class="line">&#x2F;&#x2F;        for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">&#x2F;&#x2F;            new Thread(() -&gt; &#123;</span><br><span class="line">&#x2F;&#x2F;                list.add(UUID.randomUUID().toString().substring(0, 5));</span><br><span class="line">&#x2F;&#x2F;                System.out.println(Thread.currentThread().getName() + &quot;&#x3D;&#x3D;&gt; &quot; + list);</span><br><span class="line">&#x2F;&#x2F;            &#125;, String.valueOf(i)).start();</span><br><span class="line">&#x2F;&#x2F;        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;3.CopyOnWriteArrayList</span><br><span class="line">        List&lt;String&gt; list &#x3D; new CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">            new Thread(() -&gt; &#123;</span><br><span class="line">                list.add(UUID.randomUUID().toString().substring(0, 5));</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot;&#x3D;&#x3D;&gt; &quot; + list);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="CopyOnWriteArraySet"><a href="#CopyOnWriteArraySet" class="headerlink" title="CopyOnWriteArraySet"></a>CopyOnWriteArraySet</h5><p>Hashset的底层是什么？</p>
<p><img src="JUC/image-20200422222227341.png" alt="image-20200422222227341"></p>
<p><img src="JUC/image-20200422222838848.png" alt="image-20200422222838848"></p>
<p><img src="JUC/image-20200422222859169.png" alt="image-20200422222859169"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.Collections;</span><br><span class="line">import java.util.HashSet;</span><br><span class="line">import java.util.Set;</span><br><span class="line">import java.util.UUID;</span><br><span class="line">import java.util.concurrent.CopyOnWriteArraySet;</span><br><span class="line"></span><br><span class="line">public class TestSet &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">&#x2F;&#x2F;        Set&lt;String&gt; set &#x3D; new HashSet&lt;&gt;();</span><br><span class="line">&#x2F;&#x2F;        for (int i &#x3D; 0; i &lt; 30; i++) &#123;</span><br><span class="line">&#x2F;&#x2F;            &#x2F;&#x2F;ConcurrentModificationException</span><br><span class="line">&#x2F;&#x2F;            new Thread(() -&gt; &#123;</span><br><span class="line">&#x2F;&#x2F;                set.add(UUID.randomUUID().toString().substring(0,5));</span><br><span class="line">&#x2F;&#x2F;                System.out.println(set);</span><br><span class="line">&#x2F;&#x2F;            &#125;, String.valueOf(i)).start();</span><br><span class="line">&#x2F;&#x2F;        &#125;</span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 解决方案：</span><br><span class="line">         * 1.Collections.synchronizedSet(new HashSet&lt;&gt;())</span><br><span class="line">         * 2.CopyOnWriteArraySet</span><br><span class="line">         *&#x2F;</span><br><span class="line">&#x2F;&#x2F;        Set&lt;String&gt; set &#x3D; Collections.synchronizedSet(new HashSet&lt;&gt;());</span><br><span class="line">&#x2F;&#x2F;        for (int i &#x3D; 0; i &lt; 30; i++) &#123;</span><br><span class="line">&#x2F;&#x2F;            &#x2F;&#x2F;ConcurrentModificationException</span><br><span class="line">&#x2F;&#x2F;            new Thread(() -&gt; &#123;</span><br><span class="line">&#x2F;&#x2F;                set.add(UUID.randomUUID().toString().substring(0,5));</span><br><span class="line">&#x2F;&#x2F;                System.out.println(set);</span><br><span class="line">&#x2F;&#x2F;            &#125;, String.valueOf(i)).start();</span><br><span class="line">&#x2F;&#x2F;        &#125;</span><br><span class="line"></span><br><span class="line">        Set&lt;String&gt; set &#x3D; new CopyOnWriteArraySet&lt;&gt;();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 30; i++) &#123;</span><br><span class="line">            new Thread(() -&gt; &#123;</span><br><span class="line">                set.add(UUID.randomUUID().toString().substring(0, 5));</span><br><span class="line">                System.out.println(set);</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class TestMap &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">&#x2F;&#x2F;        Map&lt;String,String&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">&#x2F;&#x2F;        &#x2F;&#x2F;ConcurrentModificationException</span><br><span class="line">&#x2F;&#x2F;        for (int i &#x3D; 0; i &lt; 30; i++) &#123;</span><br><span class="line">&#x2F;&#x2F;            new Thread(()-&gt;&#123;</span><br><span class="line">&#x2F;&#x2F;                map.put(Thread.currentThread().getName(), UUID.randomUUID().toString().substring(0,5));</span><br><span class="line">&#x2F;&#x2F;                System.out.println(map);</span><br><span class="line">&#x2F;&#x2F;            &#125;,String.valueOf(i)).start();</span><br><span class="line">&#x2F;&#x2F;        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 解决方案：</span><br><span class="line">         * 1.</span><br><span class="line">         * 2.</span><br><span class="line">         *&#x2F;</span><br><span class="line">&#x2F;&#x2F;        Map&lt;String,String&gt; map &#x3D; Collections.synchronizedMap(new HashMap&lt;&gt;());</span><br><span class="line">&#x2F;&#x2F;        &#x2F;&#x2F;ConcurrentModificationException</span><br><span class="line">&#x2F;&#x2F;        for (int i &#x3D; 0; i &lt; 30; i++) &#123;</span><br><span class="line">&#x2F;&#x2F;            new Thread(()-&gt;&#123;</span><br><span class="line">&#x2F;&#x2F;                map.put(Thread.currentThread().getName(), UUID.randomUUID().toString().substring(0,5));</span><br><span class="line">&#x2F;&#x2F;                System.out.println(map);</span><br><span class="line">&#x2F;&#x2F;            &#125;,String.valueOf(i)).start();</span><br><span class="line">&#x2F;&#x2F;        &#125;</span><br><span class="line">        Map&lt;String,String&gt; map &#x3D; new ConcurrentHashMap&lt;&gt;();</span><br><span class="line">        &#x2F;&#x2F;ConcurrentModificationException</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 30; i++) &#123;</span><br><span class="line">            new Thread(()-&gt;&#123;</span><br><span class="line">                map.put(Thread.currentThread().getName(), UUID.randomUUID().toString().substring(0,5));</span><br><span class="line">                System.out.println(map);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-Callable"><a href="#7-Callable" class="headerlink" title="7.Callable"></a>7.Callable</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class TestCallable &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;new Thread(new MyThread()).start();</span><br><span class="line">        MyCallable callable &#x3D; new MyCallable();</span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask &#x3D; new FutureTask&lt;Integer&gt;(callable);</span><br><span class="line">        new Thread(futureTask).start();</span><br><span class="line">        try &#123;</span><br><span class="line">            Integer integer &#x3D; futureTask.get();</span><br><span class="line">            System.out.println(integer);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyThread implements Runnable&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;run()&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyCallable implements Callable&lt;Integer&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Integer call() throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;call()&quot;);</span><br><span class="line">        return 1024;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="JUC/image-20200422231819081.png" alt="image-20200422231819081"></p>
<p><img src="JUC/image-20200422231941208.png" alt="image-20200422231941208"></p>
<p><img src="JUC/image-20200422233013050.png" alt="image-20200422233013050"></p>
<p>注意细节：</p>
<p>1.结果会被缓存</p>
<p>2.结果可能会等待，会阻塞</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.concurrent.Callable;</span><br><span class="line">import java.util.concurrent.FutureTask;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">public class TestCallable &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MyCallable callable &#x3D; new MyCallable();</span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask &#x3D; new FutureTask&lt;Integer&gt;(callable);</span><br><span class="line">        new Thread(futureTask,&quot;A&quot;).start();&#x2F;&#x2F;结果会被缓存</span><br><span class="line">        new Thread(futureTask,&quot;B&quot;).start();</span><br><span class="line">        try &#123;</span><br><span class="line">            Integer integer &#x3D; futureTask.get();&#x2F;&#x2F;结果可能会等待，会阻塞</span><br><span class="line">            System.out.println(integer);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class MyCallable implements Callable&lt;Integer&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Integer call() throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;call()&quot;);</span><br><span class="line">        TimeUnit.SECONDS.sleep(2);</span><br><span class="line">        return 1024;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">call()</span><br><span class="line">1024</span><br></pre></td></tr></table></figure>

<h2 id="8-常用的辅助类"><a href="#8-常用的辅助类" class="headerlink" title="8.常用的辅助类"></a>8.常用的辅助类</h2><h4 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h4><p><img src="image-20200423000153185.png" alt="image-20200423000153185"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line">public class CountDownLatchDemo &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 值日生在班中所有学生都放学离开教室后，才关闭教室的门</span><br><span class="line">     *</span><br><span class="line">     * @param args</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        CountDownLatch latch &#x3D; new CountDownLatch(6);</span><br><span class="line"></span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; 6; i++) &#123;</span><br><span class="line">            new Thread(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot;离开了教室！&quot;);</span><br><span class="line">                latch.countDown();</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;等计数器归0</span><br><span class="line">            latch.await();</span><br><span class="line">            System.out.println(&quot;值日生关门！！！&quot;);</span><br><span class="line"></span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1离开了教室！</span><br><span class="line">5离开了教室！</span><br><span class="line">6离开了教室！</span><br><span class="line">2离开了教室！</span><br><span class="line">4离开了教室！</span><br><span class="line">3离开了教室！</span><br><span class="line">值日生关门！！！</span><br></pre></td></tr></table></figure>

<h4 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h4><p><img src="JUC/image-20200423000915243.png" alt="image-20200423000915243"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.concurrent.BrokenBarrierException;</span><br><span class="line">import java.util.concurrent.CyclicBarrier;</span><br><span class="line"></span><br><span class="line">public class CyclicBarrierDemo &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 可以理解为加法计数器</span><br><span class="line">     * 集齐七颗龙珠，召唤神龙</span><br><span class="line">     *</span><br><span class="line">     * @param args</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        CyclicBarrier cyclicBarrier &#x3D; new CyclicBarrier(7, () -&gt; &#123;</span><br><span class="line">            System.out.println(&quot;召唤神龙&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; 7; i++) &#123;</span><br><span class="line">            final int temp &#x3D; i;</span><br><span class="line">            new Thread(() -&gt; &#123;</span><br><span class="line">                System.out.println(&quot;线程&quot;+Thread.currentThread().getName()+&quot;收集到编号为&quot;+temp+&quot;的龙珠&quot;);</span><br><span class="line">                try &#123;</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; catch (BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">线程1收集到编号为1的龙珠</span><br><span class="line">线程4收集到编号为4的龙珠</span><br><span class="line">线程5收集到编号为5的龙珠</span><br><span class="line">线程2收集到编号为2的龙珠</span><br><span class="line">线程3收集到编号为3的龙珠</span><br><span class="line">线程7收集到编号为7的龙珠</span><br><span class="line">线程6收集到编号为6的龙珠</span><br><span class="line">召唤神龙</span><br></pre></td></tr></table></figure>

<h4 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.concurrent.Semaphore;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">public class SemaphoreDemo &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 抢车位，6辆车，3个车位</span><br><span class="line">     *</span><br><span class="line">     * @param args</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;3个车位</span><br><span class="line">        Semaphore semaphore &#x3D; new Semaphore(3);</span><br><span class="line"></span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; 6; i++) &#123;</span><br><span class="line">            new Thread(() -&gt; &#123;</span><br><span class="line">                &#x2F;&#x2F;获得</span><br><span class="line">                try &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot;进入了车位&quot;);</span><br><span class="line">                    TimeUnit.SECONDS.sleep(2);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + &quot;离开了车位&quot;);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, &quot;汽车&quot; + String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">汽车1进入了车位</span><br><span class="line">汽车3进入了车位</span><br><span class="line">汽车2进入了车位</span><br><span class="line">汽车1离开了车位</span><br><span class="line">汽车3离开了车位</span><br><span class="line">汽车2离开了车位</span><br><span class="line">汽车4进入了车位</span><br><span class="line">汽车6进入了车位</span><br><span class="line">汽车5进入了车位</span><br><span class="line">汽车4离开了车位</span><br><span class="line">汽车6离开了车位</span><br><span class="line">汽车5离开了车位</span><br></pre></td></tr></table></figure>

<p>原理：</p>
<p><code>semaphore.acquire()</code>获得，假设如果已经满了，等待，等待被释放为止！</p>
<p><code>semaphore.release()</code>释放，会将当前的信号量释放+1，然后唤醒等待的线程！</p>
<h2 id="9-读写锁"><a href="#9-读写锁" class="headerlink" title="9.读写锁"></a>9.读写锁</h2><p><img src="JUC/image-20200423074900178.png" alt="image-20200423074900178"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.concurrent.locks.ReadWriteLock;</span><br><span class="line">import java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 独占锁（写锁） -次只能被一个线程占有</span><br><span class="line"> * 共享锁（读锁） 多个线程可以同时占有</span><br><span class="line"> *</span><br><span class="line"> * ReadWriteLock</span><br><span class="line"> * 读-读 可以共存</span><br><span class="line"> * 读-写 不能共存</span><br><span class="line"> * 写-写 不能共存</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">public class ReadWriteLockDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;没有锁</span><br><span class="line">&#x2F;&#x2F;        MyCache myCache &#x3D; new MyCache();</span><br><span class="line">        &#x2F;&#x2F;有锁的缓存</span><br><span class="line">        MyReadRriteLockCache myCache &#x3D; new MyReadRriteLockCache();</span><br><span class="line">        &#x2F;&#x2F;10个线程写数据</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">            final int temp &#x3D; i;</span><br><span class="line">            new Thread(()-&gt;&#123;</span><br><span class="line">                myCache.put(temp+&quot;&quot;,Thread.currentThread().getName());</span><br><span class="line">            &#125;,&quot;线程&quot;+String.valueOf(temp)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;10个线程读数据</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">            final  int temp &#x3D; i;</span><br><span class="line">            new Thread(()-&gt;&#123;</span><br><span class="line">                myCache.get(temp+&quot;&quot;);</span><br><span class="line">            &#125;,String.valueOf(temp)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyCache&#123;</span><br><span class="line">    private volatile Map&lt;String,Object&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public void put(String key,Object value)&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+&quot;写入数据开始&quot;);</span><br><span class="line">        map.put(key,value);</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+&quot;写入数据OK&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void get(String key)&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+&quot;读取数据开始&quot;);</span><br><span class="line">        Object o &#x3D; map.get(key);</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+&quot;读取数据OK&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 带读写锁的缓存</span><br><span class="line"> *&#x2F;</span><br><span class="line">class MyReadRriteLockCache&#123;</span><br><span class="line">    private volatile Map&lt;String,Object&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    final ReadWriteLock readWriteLock &#x3D; new ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">    public void put(String key,Object value)&#123;</span><br><span class="line">        readWriteLock.writeLock().lock();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot;写入数据开始&quot;);</span><br><span class="line">            map.put(key,value);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot;写入数据OK&quot;);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            readWriteLock.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void get(String key)&#123;</span><br><span class="line">        readWriteLock.readLock().lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot;读取数据开始&quot;);</span><br><span class="line">            Object o &#x3D; map.get(key);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot;读取数据OK&quot;);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            readWriteLock.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">线程0写入数据开始</span><br><span class="line">线程0写入数据OK</span><br><span class="line">线程1写入数据开始</span><br><span class="line">线程1写入数据OK</span><br><span class="line">线程6写入数据开始</span><br><span class="line">线程6写入数据OK</span><br><span class="line">线程2写入数据开始</span><br><span class="line">线程2写入数据OK</span><br><span class="line">线程8写入数据开始</span><br><span class="line">线程8写入数据OK</span><br><span class="line">线程3写入数据开始</span><br><span class="line">线程3写入数据OK</span><br><span class="line">线程4写入数据开始</span><br><span class="line">线程4写入数据OK</span><br><span class="line">线程5写入数据开始</span><br><span class="line">线程5写入数据OK</span><br><span class="line">线程7写入数据开始</span><br><span class="line">线程7写入数据OK</span><br><span class="line">线程9写入数据开始</span><br><span class="line">线程9写入数据OK</span><br><span class="line">0读取数据开始</span><br><span class="line">0读取数据OK</span><br><span class="line">2读取数据开始</span><br><span class="line">3读取数据开始</span><br><span class="line">1读取数据开始</span><br><span class="line">1读取数据OK</span><br><span class="line">3读取数据OK</span><br><span class="line">6读取数据开始</span><br><span class="line">4读取数据开始</span><br><span class="line">4读取数据OK</span><br><span class="line">2读取数据OK</span><br><span class="line">8读取数据开始</span><br><span class="line">9读取数据开始</span><br><span class="line">7读取数据开始</span><br><span class="line">6读取数据OK</span><br><span class="line">5读取数据开始</span><br><span class="line">7读取数据OK</span><br><span class="line">9读取数据OK</span><br><span class="line">8读取数据OK</span><br><span class="line">5读取数据OK</span><br></pre></td></tr></table></figure>

<h2 id="10-阻塞队列"><a href="#10-阻塞队列" class="headerlink" title="10.阻塞队列"></a>10.阻塞队列</h2><h4 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h4><p><img src="JUC/image-20200423083817588.png" alt="image-20200423083817588"></p>
<p><strong>学会使用队列</strong></p>
<p>添加、移除</p>
<p><strong>四组API</strong></p>
<table>
<thead>
<tr>
<th>方式</th>
<th>抛出异常</th>
<th>有返回值，不抛出异常</th>
<th>阻塞等待</th>
<th>超时等待</th>
</tr>
</thead>
<tbody><tr>
<td>添加</td>
<td>add()</td>
<td>offer()</td>
<td>put()</td>
<td>offer(E e, long timeout, TimeUnit unit)</td>
</tr>
<tr>
<td>移除</td>
<td>remove()</td>
<td>poll()</td>
<td>take()</td>
<td>poll(long timeout, TimeUnit unit)</td>
</tr>
<tr>
<td>检测队首元素</td>
<td>element()</td>
<td>peek()</td>
<td>-</td>
<td>-</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">public class BlockingQueueDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        &#x2F;&#x2F;test01();</span><br><span class="line">        &#x2F;&#x2F;test02();</span><br><span class="line">        &#x2F;&#x2F;test03();</span><br><span class="line">        test04();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 抛出异常</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void test01()&#123;</span><br><span class="line">        ArrayBlockingQueue queue &#x3D; new ArrayBlockingQueue(3);</span><br><span class="line">        System.out.println(queue.add(&quot;a&quot;));</span><br><span class="line">        System.out.println(queue.add(&quot;b&quot;));</span><br><span class="line">        System.out.println(queue.add(&quot;c&quot;));</span><br><span class="line">        &#x2F;&#x2F;java.lang.IllegalStateException: Queue full</span><br><span class="line">        &#x2F;&#x2F;queue.add(&quot;d&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(queue.remove());</span><br><span class="line">        System.out.println(queue.remove());</span><br><span class="line">        System.out.println(queue.remove());</span><br><span class="line">        &#x2F;&#x2F;java.util.NoSuchElementException</span><br><span class="line">        System.out.println(&quot;队首元素：&quot;+queue.element());</span><br><span class="line">        &#x2F;&#x2F;java.util.NoSuchElementException</span><br><span class="line">        &#x2F;&#x2F;System.out.println(queue.remove());</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 有返回值，不抛出异常</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void test02()&#123;</span><br><span class="line">        ArrayBlockingQueue queue &#x3D; new ArrayBlockingQueue(3);</span><br><span class="line">        System.out.println(queue.offer(&quot;a&quot;));</span><br><span class="line">        System.out.println(queue.offer(&quot;b&quot;));</span><br><span class="line">        System.out.println(queue.offer(&quot;c&quot;));</span><br><span class="line">        &#x2F;&#x2F;返回false</span><br><span class="line">        &#x2F;&#x2F;System.out.println(queue.offer(&quot;d&quot;));</span><br><span class="line"></span><br><span class="line">        System.out.println(queue.poll());</span><br><span class="line">        System.out.println(queue.poll());</span><br><span class="line">        System.out.println(queue.poll());</span><br><span class="line">        &#x2F;&#x2F;队首元素：null</span><br><span class="line">        System.out.println(&quot;队首元素：&quot;+queue.peek());</span><br><span class="line">        &#x2F;&#x2F;返回null</span><br><span class="line">        System.out.println(queue.poll());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 阻塞等待</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void test03() throws InterruptedException &#123;</span><br><span class="line">        ArrayBlockingQueue queue &#x3D; new ArrayBlockingQueue(3);</span><br><span class="line">        queue.put(&quot;a&quot;);</span><br><span class="line">        queue.put(&quot;b&quot;);</span><br><span class="line">        queue.put(&quot;c&quot;);</span><br><span class="line">        &#x2F;&#x2F;阻塞等待</span><br><span class="line">        &#x2F;&#x2F;queue.put(&quot;d&quot;);</span><br><span class="line">        System.out.println(queue.take());</span><br><span class="line">        System.out.println(queue.take());</span><br><span class="line">        System.out.println(queue.take());</span><br><span class="line">        &#x2F;&#x2F;阻塞等待</span><br><span class="line">        &#x2F;&#x2F;System.out.println(queue.take());</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 超时等待</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void test04() throws InterruptedException &#123;</span><br><span class="line">        ArrayBlockingQueue queue &#x3D; new ArrayBlockingQueue(3);</span><br><span class="line">        queue.offer(&quot;a&quot;,2, TimeUnit.SECONDS);</span><br><span class="line">        queue.offer(&quot;b&quot;,2, TimeUnit.SECONDS);</span><br><span class="line">        queue.offer(&quot;c&quot;,2, TimeUnit.SECONDS);</span><br><span class="line">        &#x2F;&#x2F;两秒钟后超时，退出阻塞</span><br><span class="line">        queue.offer(&quot;d&quot;,2, TimeUnit.SECONDS);</span><br><span class="line">        System.out.println(queue.poll(1, TimeUnit.SECONDS));</span><br><span class="line">        System.out.println(queue.poll(1, TimeUnit.SECONDS));</span><br><span class="line">        System.out.println(queue.poll(1, TimeUnit.SECONDS));</span><br><span class="line">        &#x2F;&#x2F;&#x2F;&#x2F;两秒钟后超时，返回null</span><br><span class="line">        System.out.println(queue.poll(1, TimeUnit.SECONDS));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h4><p><img src="JUC/image-20200423093223548.png" alt="image-20200423093223548"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.concurrent.BlockingQueue;</span><br><span class="line">import java.util.concurrent.SynchronousQueue;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">public class SynchronousQueueDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        BlockingQueue&lt;String&gt; blockingQueue &#x3D; new SynchronousQueue&lt;&gt;();</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+&quot; put 1&quot;);</span><br><span class="line">                blockingQueue.put(&quot;1&quot;);</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+&quot; put 2&quot;);</span><br><span class="line">                blockingQueue.put(&quot;2&quot;);</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+&quot; put 3&quot;);</span><br><span class="line">                blockingQueue.put(&quot;3&quot;);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;, &quot;T1&quot;).start();</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(3);</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+&quot; &#x3D;&gt; &quot; +blockingQueue.take());</span><br><span class="line">                TimeUnit.SECONDS.sleep(3);</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+&quot; &#x3D;&gt; &quot; +blockingQueue.take());</span><br><span class="line">                TimeUnit.SECONDS.sleep(3);</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+&quot; &#x3D;&gt; &quot; +blockingQueue.take());</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;T2&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="11-线程池（重点）"><a href="#11-线程池（重点）" class="headerlink" title="11.线程池（重点）"></a>11.线程池（重点）</h2><p>线程池：3大方法、7大参数、4种拒绝策略</p>
<p>池化技术***</p>
<p>程序的运行本质：占用系统的资源！优化资源的使用！=&gt;池化技术</p>
<p>线程池、连接池、内存池、对象池//…创建、销毁，十分浪费资源</p>
<p>池化技术：事先准备好一些资源，有人要用，就来我这里拿，用完之后还给我。</p>
<p><strong><em>线程池的好处：\</em></strong></p>
<p>1.降低资源的消耗</p>
<p>2.提高相应的速度</p>
<p>3.方便管理</p>
<p>线程复用，可以控制最大并发数、管理线程。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ThreadPoolDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">&#x2F;&#x2F;        ExecutorService threadPool &#x3D; Executors.newSingleThreadExecutor();&#x2F;&#x2F;单个线程</span><br><span class="line">&#x2F;&#x2F;       ExecutorService threadPool &#x3D;  Executors.newFixedThreadPool(5);&#x2F;&#x2F;固定线程池容量</span><br><span class="line">        ExecutorService threadPool &#x3D; Executors.newCachedThreadPool();&#x2F;&#x2F; 可伸缩容量,遇强则强</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            for (int i &#x3D; 0; i &lt; 100; i++) &#123;</span><br><span class="line">                threadPool.execute(() -&gt; &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName());</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="3大方法："><a href="#3大方法：" class="headerlink" title="3大方法：\"></a><strong><em>3大方法：\</em></strong></h5><p>Executors.newSingleThreadExecutor();//单个线程</p>
<p>Executors.newFixedThreadPool(5);//固定线程池大小</p>
<p>Executors.newCachedThreadPool();// 可伸缩容量,遇强则强，遇弱则弱</p>
<h5 id="7大参数："><a href="#7大参数：" class="headerlink" title="7大参数：\"></a><strong><em>7大参数：\</em></strong></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static ExecutorService newSingleThreadExecutor() &#123;</span><br><span class="line">  return new FinalizableDelegatedExecutorService</span><br><span class="line">    (new ThreadPoolExecutor(1, 1,</span><br><span class="line">                            0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                            new LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br><span class="line">public static ExecutorService newFixedThreadPool(int nThreads) &#123;</span><br><span class="line">  return new ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                new LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line">public static ExecutorService newCachedThreadPool() &#123;</span><br><span class="line">  return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</span><br><span class="line">                                60L, TimeUnit.SECONDS,</span><br><span class="line">                                new SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;**</span><br><span class="line">     * Creates a new &#123;@code ThreadPoolExecutor&#125; with the given initial</span><br><span class="line">     * parameters.</span><br><span class="line">     *</span><br><span class="line">     * @param corePoolSize the number of threads to keep in the pool, even</span><br><span class="line">     *        if they are idle, unless &#123;@code allowCoreThreadTimeOut&#125; is set</span><br><span class="line">     * @param maximumPoolSize the maximum number of threads to allow in the</span><br><span class="line">     *        pool</span><br><span class="line">     * @param keepAliveTime when the number of threads is greater than</span><br><span class="line">     *        the core, this is the maximum time that excess idle threads</span><br><span class="line">     *        will wait for new tasks before terminating.</span><br><span class="line">     * @param unit the time unit for the &#123;@code keepAliveTime&#125; argument</span><br><span class="line">     * @param workQueue the queue to use for holding tasks before they are</span><br><span class="line">     *        executed.  This queue will hold only the &#123;@code Runnable&#125;</span><br><span class="line">     *        tasks submitted by the &#123;@code execute&#125; method.</span><br><span class="line">     * @param threadFactory the factory to use when the executor</span><br><span class="line">     *        creates a new thread</span><br><span class="line">     * @param handler the handler to use when execution is blocked</span><br><span class="line">     *        because the thread bounds and queue capacities are reached</span><br><span class="line">     * @throws IllegalArgumentException if one of the following holds:&lt;br&gt;</span><br><span class="line">     *         &#123;@code corePoolSize &lt; 0&#125;&lt;br&gt;</span><br><span class="line">     *         &#123;@code keepAliveTime &lt; 0&#125;&lt;br&gt;</span><br><span class="line">     *         &#123;@code maximumPoolSize &lt;&#x3D; 0&#125;&lt;br&gt;</span><br><span class="line">     *         &#123;@code maximumPoolSize &lt; corePoolSize&#125;</span><br><span class="line">     * @throws NullPointerException if &#123;@code workQueue&#125;</span><br><span class="line">     *         or &#123;@code threadFactory&#125; or &#123;@code handler&#125; is null</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public ThreadPoolExecutor(int corePoolSize,&#x2F;&#x2F;核心线程池大小</span><br><span class="line">                              int maximumPoolSize,&#x2F;&#x2F;最大线程池大小</span><br><span class="line">                              long keepAliveTime,&#x2F;&#x2F;超时了没有调用就会释放</span><br><span class="line">                              TimeUnit unit,&#x2F;&#x2F;超时单位</span><br><span class="line">                              BlockingQueue&lt;Runnable&gt; workQueue,&#x2F;&#x2F;阻塞队列</span><br><span class="line">                              ThreadFactory threadFactory,&#x2F;&#x2F;线程工厂：创建线程，一般不用动</span><br><span class="line">                              RejectedExecutionHandler handler&#x2F;&#x2F;拒绝策略) &#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="JUC/image-20200423102614915.png" alt="image-20200423102614915"></p>
<h5 id="4种拒绝策略-："><a href="#4种拒绝策略-：" class="headerlink" title="4种拒绝策略\："></a><strong><em>4种拒绝策略\</em></strong>：</h5><ol>
<li>new ThreadPoolExecutor.AbortPolicy() 银行满了，还有人进来，不处理这个人的，抛出异常 java.util.concurrent.RejectedExecutionException</li>
<li>new ThreadPoolExecutor.CallerRunsPolicy() 哪来的去哪里</li>
<li>new ThreadPoolExecutor.DiscardPolicy() 队列满了，丢掉任务，不会抛出异常</li>
<li>new ThreadPoolExecutor.DiscardOldestPolicy() 队列满了，尝试去和最早的竞争，也不会抛出异常</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line">public class ThreadPoolDemo1 &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * new ThreadPoolExecutor.AbortPolicy() 银行满了，还有人进来，不处理这个人的，抛出异常 java.util.concurrent.RejectedExecutionException</span><br><span class="line">     * new ThreadPoolExecutor.CallerRunsPolicy() 哪来的去哪里</span><br><span class="line">     * new ThreadPoolExecutor.DiscardPolicy() 队列满了，丢掉任务，不会抛出异常</span><br><span class="line">     * new ThreadPoolExecutor.DiscardOldestPolicy() 队列满了，尝试去和最早的竞争，也不会抛出异常</span><br><span class="line">     *</span><br><span class="line">     * @param args</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ThreadPoolExecutor threadPoolExecutor &#x3D; new ThreadPoolExecutor(</span><br><span class="line">                2,</span><br><span class="line">                5,</span><br><span class="line">                10,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                new LinkedBlockingQueue&lt;&gt;(3),</span><br><span class="line">                Executors.defaultThreadFactory(),</span><br><span class="line">                new ThreadPoolExecutor.DiscardOldestPolicy());</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            for (int i &#x3D; 0; i &lt; 9; i++) &#123;</span><br><span class="line">                threadPoolExecutor.execute(()-&gt;&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName());</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            threadPoolExecutor.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="线程小结："><a href="#线程小结：" class="headerlink" title="线程小结："></a>线程小结：</h5><p>CPU密集型和IO密集型</p>
<p>最大线程到底如何定义：</p>
<p>1.CPU密集型：几核就是几，可以保持CPU的效率最高！</p>
<p>2.IO密集型： 判断程序中十分耗IO的线程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.concurrent.Executors;</span><br><span class="line">import java.util.concurrent.LinkedBlockingQueue;</span><br><span class="line">import java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">public class ThreadPoolDemo2 &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * CPU密集型、IO密集型</span><br><span class="line">     * 最大线程到底如何定义：</span><br><span class="line">     *</span><br><span class="line">     * 1.CPU密集型：几核就是几，可以保持CPU的效率最高！</span><br><span class="line">     *</span><br><span class="line">     * 2.IO密集型： 判断程序中十分耗IO的线程</span><br><span class="line">     * @param args</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ThreadPoolExecutor threadPoolExecutor &#x3D; new ThreadPoolExecutor(</span><br><span class="line">                2,</span><br><span class="line">                Runtime.getRuntime().availableProcessors(),</span><br><span class="line">                10,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                new LinkedBlockingQueue&lt;&gt;(3),</span><br><span class="line">                Executors.defaultThreadFactory(),</span><br><span class="line">                new ThreadPoolExecutor.DiscardOldestPolicy());</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            for (int i &#x3D; 0; i &lt; 9; i++) &#123;</span><br><span class="line">                threadPoolExecutor.execute(()-&gt;&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName());</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            threadPoolExecutor.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="12-四大函数式接口（必须掌握）"><a href="#12-四大函数式接口（必须掌握）" class="headerlink" title="12.四大函数式接口（必须掌握）"></a>12.四大函数式接口（必须掌握）</h2><p>新时代的程序员：lambda表达式、链式编程、函数式接口、Stream流</p>
<p><img src="JUC/image-20200423114019393.png" alt="image-20200423114019393"></p>
<blockquote>
<p>函数式接口:只有一个方法的接口</p>
</blockquote>
<p><img src="JUC/image-20200423115336165.png" alt="image-20200423115336165"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface Function&lt;T, R&gt; &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Applies this function to the given argument.</span><br><span class="line">     *</span><br><span class="line">     * @param t the function argument</span><br><span class="line">     * @return the function result</span><br><span class="line">     *&#x2F;</span><br><span class="line">    R apply(T t);</span><br><span class="line">&#125;    </span><br><span class="line">@FunctionalInterface</span><br><span class="line">public interface Runnable &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * When an object implementing interface &lt;code&gt;Runnable&lt;&#x2F;code&gt; is used</span><br><span class="line">     * to create a thread, starting the thread causes the object&#39;s</span><br><span class="line">     * &lt;code&gt;run&lt;&#x2F;code&gt; method to be called in that separately executing</span><br><span class="line">     * thread.</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * The general contract of the method &lt;code&gt;run&lt;&#x2F;code&gt; is that it may</span><br><span class="line">     * take any action whatsoever.</span><br><span class="line">     *</span><br><span class="line">     * @see     java.lang.Thread#run()</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public abstract void run();</span><br><span class="line">&#125;</span><br><span class="line">import java.util.function.Function;</span><br><span class="line"></span><br><span class="line">public class FunctionDemo &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 函数式编程</span><br><span class="line">     * @param args</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Function&lt;String,String&gt; fun &#x3D; new Function&lt;String, String&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public String apply(String s) &#123;</span><br><span class="line">                return s;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(fun.apply(&quot;hello world!&quot;));</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;-----------------&quot;);</span><br><span class="line"></span><br><span class="line">        Function&lt;String,String&gt; myFun &#x3D; (str)-&gt;&#123;</span><br><span class="line">            return str;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(myFun.apply(&quot;hello java!&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Predicate 断定型接口看，有一个输入参数，返回值只能是布尔值！</p>
</blockquote>
<p><img src="JUC/image-20200423115736994.png" alt="image-20200423115736994"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Predicate:断定型接口看，有一个输入参数，返回值只能是布尔值！</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class PredicateDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Predicate&lt;String&gt; predicate &#x3D; new Predicate&lt;String&gt;() &#123;</span><br><span class="line">            &#x2F;&#x2F;判断字符串是否为空</span><br><span class="line">            @Override</span><br><span class="line">            public boolean test(String s) &#123;</span><br><span class="line">                return s.isEmpty();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(predicate.test(&quot;hello&quot;));</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;----------------&quot;);</span><br><span class="line"></span><br><span class="line">        Predicate&lt;String&gt; myPredicate &#x3D; (str)-&gt;&#123;</span><br><span class="line">            return str.isEmpty();</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(predicate.test(&quot;hello&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>消费型接口</p>
</blockquote>
<p><img src="JUC/image-20200423120813949.png" alt="image-20200423120813949"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.function.Consumer;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 消费型接口:有一个输入参数，无返回参数</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class ConsumerDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Consumer&lt;String&gt; consumer &#x3D; new Consumer&lt;String&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void accept(String s) &#123;</span><br><span class="line">                System.out.println(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        consumer.accept(&quot;hello world!&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;---------------&quot;);</span><br><span class="line"></span><br><span class="line">        Consumer&lt;String&gt; consumer1 &#x3D; (str) -&gt; &#123;</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;;</span><br><span class="line">        consumer1.accept(&quot;hello java!&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Supplier 供给型接口：无输入参数，有返回值</p>
</blockquote>
<p><img src="JUC/image-20200423121705808.png" alt="image-20200423121705808"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.UUID;</span><br><span class="line">import java.util.function.Supplier;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * g供给型接口：无输入参数，有返回值</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class SupplierDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Supplier&lt;String&gt; supplier &#x3D; new Supplier&lt;String&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public String get() &#123;</span><br><span class="line">                return UUID.randomUUID().toString().replace(&quot;-&quot;,&quot;&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(supplier.get());</span><br><span class="line">        System.out.println(&quot;------------------&quot;);</span><br><span class="line"></span><br><span class="line">        Supplier&lt;String&gt; supplier1 &#x3D; () -&gt;&#123;</span><br><span class="line">            return UUID.randomUUID().toString().replace(&quot;-&quot;,&quot;&quot;);</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(supplier1.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="13-Stream流式计算"><a href="#13-Stream流式计算" class="headerlink" title="13.Stream流式计算"></a>13.Stream流式计算</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import lombok.AllArgsConstructor;</span><br><span class="line">import lombok.Data;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 题目要求：一分钟完成此题，只能用一行代码实现！</span><br><span class="line"> * 现在有5个用户！筛选：</span><br><span class="line"> * 1、ID必须是偶数</span><br><span class="line"> * 2、年龄必须大于23岁</span><br><span class="line"> * 3、用户名转为大写字母</span><br><span class="line"> * 4、用户名字母倒着排序</span><br><span class="line"> * 5、只输出一个用户！</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class StreamDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        User u1 &#x3D; new User(1, &quot;zhangsan&quot;, 21);</span><br><span class="line">        User u2 &#x3D; new User(2, &quot;lisi&quot;, 22);</span><br><span class="line">        User u3 &#x3D; new User(3, &quot;wangwu&quot;, 23);</span><br><span class="line">        User u4 &#x3D; new User(4, &quot;zhaoliu&quot;, 24);</span><br><span class="line">        User u5 &#x3D; new User(5, &quot;houqi&quot;, 25);</span><br><span class="line">        User u6 &#x3D; new User(6, &quot;laiba&quot;, 26);</span><br><span class="line">        List&lt;User&gt; users &#x3D; Arrays.asList(u1, u2, u3, u4, u5,u6);</span><br><span class="line">        users.stream()</span><br><span class="line">                .filter((u) -&gt; &#123;</span><br><span class="line">                    return u.getId() % 2 &#x3D;&#x3D; 0;</span><br><span class="line">                &#125;)</span><br><span class="line">                .filter((u) -&gt; &#123;</span><br><span class="line">                    return u.getAge() &gt; 23;</span><br><span class="line">                &#125;)</span><br><span class="line">                .map((u) -&gt; &#123;</span><br><span class="line">                    return u.getName().toUpperCase();</span><br><span class="line">                &#125;)</span><br><span class="line">                .sorted((uu1, uu2) -&gt; &#123;</span><br><span class="line">                    return uu2.compareTo(uu1);</span><br><span class="line">                &#125;)</span><br><span class="line">                .limit(1)</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Data</span><br><span class="line">@AllArgsConstructor</span><br><span class="line">class User &#123;</span><br><span class="line">    private Integer id;</span><br><span class="line">    private String name;</span><br><span class="line">    private Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="14-ForkJoin"><a href="#14-ForkJoin" class="headerlink" title="14.ForkJoin"></a>14.ForkJoin</h2><blockquote>
<p>什么是ForkJoin</p>
<p>ForkJoin在JDK1.7，并行执行任务！提高效率，大数据量</p>
</blockquote>
<p>MapReduce</p>
<p><img src="JUC/image-20200423153623895.png" alt="image-20200423153623895"></p>
<p><img src="JUC//image-20200423153732271.png?lastModify=1587800694" alt="image-20200423153732271"></p>
<blockquote>
<p>ForkJoin特点：工作窃取</p>
</blockquote>
<p><img src="file:///Users/doubledumbao/Library/Application%20Support/typora-user-images/image-20200423154551429.png?lastModify=1587800694" alt="image-20200423154551429"></p>
<blockquote>
<p>ForkJoin</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.concurrent.ExecutionException;</span><br><span class="line">import java.util.concurrent.ForkJoinPool;</span><br><span class="line">import java.util.concurrent.ForkJoinTask;</span><br><span class="line">import java.util.stream.LongStream;</span><br><span class="line"></span><br><span class="line">public class TestForkJoin &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line">&#x2F;&#x2F;        test1();</span><br><span class="line">&#x2F;&#x2F;        test2();</span><br><span class="line">        test3();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;普通程序员</span><br><span class="line">    public static void test1()&#123;</span><br><span class="line">        long startTime &#x3D; System.currentTimeMillis();</span><br><span class="line">        Long sum &#x3D; 0L;</span><br><span class="line">        for (Long i &#x3D; 1L; i &lt;&#x3D; 10_0000_0000; i++) &#123;</span><br><span class="line">            sum +&#x3D; i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        long endTime &#x3D; System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;sum&#x3D;&quot;+sum+&quot;花费&quot;+(endTime-startTime));</span><br><span class="line">        &#x2F;&#x2F;sum&#x3D;500000000500000000花费7432</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;会用ForkJoin</span><br><span class="line">    public static void test2() throws ExecutionException, InterruptedException &#123;</span><br><span class="line">        long startTime &#x3D; System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        ForkJoinPool forkJoinPool &#x3D; new ForkJoinPool();</span><br><span class="line"></span><br><span class="line">        ForkJoinDemo forkJoinTask &#x3D; new ForkJoinDemo(1L, 10_0000_0000L);</span><br><span class="line"></span><br><span class="line">        ForkJoinTask&lt;Long&gt; joinTask &#x3D; forkJoinPool.submit(forkJoinTask);</span><br><span class="line"></span><br><span class="line">        Long sum &#x3D; joinTask.get();</span><br><span class="line"></span><br><span class="line">        long endTime &#x3D; System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;sum&#x3D;&quot;+sum+&quot;花费&quot;+(endTime-startTime));</span><br><span class="line">        &#x2F;&#x2F;sum&#x3D;500000000500000000花费5941</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;会用并行流</span><br><span class="line">    public static void test3()&#123;</span><br><span class="line">        long startTime &#x3D; System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        long sum &#x3D; LongStream.rangeClosed(1L, 10_0000_0000L).parallel().reduce(0, Long::sum);</span><br><span class="line"></span><br><span class="line">        long endTime &#x3D; System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;sum&#x3D;&quot;+sum+&quot;花费&quot;+(endTime-startTime));</span><br><span class="line">        &#x2F;&#x2F;sum&#x3D;500000000500000000花费334</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="15-异步回调"><a href="#15-异步回调" class="headerlink" title="15.异步回调"></a>15.异步回调</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.concurrent.CompletableFuture;</span><br><span class="line">import java.util.concurrent.ExecutionException;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 异步调用：CompletableFuture</span><br><span class="line"> * 异步执行</span><br><span class="line"> * 成功回调</span><br><span class="line"> * 失败回调</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class FutureTaskDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line">        &#x2F;&#x2F;无返回值的runAsync异步回调</span><br><span class="line">&#x2F;&#x2F;        CompletableFuture&lt;Void&gt; completableFuture &#x3D; CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">&#x2F;&#x2F;            try &#123;</span><br><span class="line">&#x2F;&#x2F;                TimeUnit.SECONDS.sleep(2);</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">&#x2F;&#x2F;                e.printStackTrace();</span><br><span class="line">&#x2F;&#x2F;            &#125;</span><br><span class="line">&#x2F;&#x2F;            System.out.println(Thread.currentThread().getName()+&quot; runAsync &quot;);</span><br><span class="line">&#x2F;&#x2F;            &#x2F;**</span><br><span class="line">&#x2F;&#x2F;             * 执行结果：</span><br><span class="line">&#x2F;&#x2F;             * 111111</span><br><span class="line">&#x2F;&#x2F;             * ForkJoinPool.commonPool-worker-1 runAsync</span><br><span class="line">&#x2F;&#x2F;             * 22222</span><br><span class="line">&#x2F;&#x2F;             *&#x2F;</span><br><span class="line">&#x2F;&#x2F;        &#125;);</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;        System.out.println(&quot;111111&quot;);</span><br><span class="line">&#x2F;&#x2F;        completableFuture.get();&#x2F;&#x2F;获取阻塞执行结果</span><br><span class="line">&#x2F;&#x2F;        System.out.println(&quot;22222&quot;);</span><br><span class="line">        &#x2F;&#x2F;有返回值的异步回调</span><br><span class="line">        CompletableFuture&lt;Integer&gt; completableFuture &#x3D; CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot; supplyAsync &#x3D;&gt; Integer&quot;);</span><br><span class="line">            int x &#x3D; 10&#x2F;0;</span><br><span class="line">            return 200;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(completableFuture.whenComplete((t, u) -&gt; &#123;</span><br><span class="line">            System.out.println(&quot;t&#x3D;&#x3D;&#x3D;&gt;&quot; + t);&#x2F;&#x2F;正常的返回结果</span><br><span class="line">            System.out.println(&quot;u&#x3D;&#x3D;&#x3D;&gt;&quot; + u);&#x2F;&#x2F;错误信息</span><br><span class="line">        &#125;).exceptionally((e) -&gt; &#123;</span><br><span class="line">            System.out.println(e.getMessage());&#x2F;&#x2F;java.lang.ArithmeticException: &#x2F; by zero</span><br><span class="line">            return 500;</span><br><span class="line">        &#125;).get());</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 成功的打印记录：</span><br><span class="line">     * ForkJoinPool.commonPool-worker-1 supplyAsync &#x3D;&gt; Integer</span><br><span class="line">     * t&#x3D;&#x3D;&#x3D;&gt;200</span><br><span class="line">     * u&#x3D;&#x3D;&#x3D;&gt;null</span><br><span class="line">     * 200</span><br><span class="line">     *&#x2F;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 失败的打印记录：</span><br><span class="line">     * ForkJoinPool.commonPool-worker-1 supplyAsync &#x3D;&gt; Integer</span><br><span class="line">     * t&#x3D;&#x3D;&#x3D;&gt;null</span><br><span class="line">     * u&#x3D;&#x3D;&#x3D;&gt;java.util.concurrent.CompletionException: java.lang.ArithmeticException: &#x2F; by zero</span><br><span class="line">     * java.lang.ArithmeticException: &#x2F; by zero</span><br><span class="line">     * 500</span><br><span class="line">     *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="16-JMM"><a href="#16-JMM" class="headerlink" title="16.JMM"></a>16.JMM</h2><p><img src="JUC/image-20200423172337152.png" alt="image-20200423172337152"></p>
<p><img src="JUC/image-20200423172016760.png?lastModify=1587800694" alt="image-20200423172016760"></p>
<h5 id="内存交互操作"><a href="#内存交互操作" class="headerlink" title="内存交互操作"></a>内存交互操作</h5><p>由上面的交互关系可知，关于主内存与工作内存之间的具体交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步到主内存之间的实现细节，Java内存模型定义了以下八种操作来完成：</p>
<ul>
<li><p>lock（锁定）：作用于主内存的变量，把一个变量标识为一条线程独占状态。</p>
</li>
<li><p>unlock（解锁）：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</p>
</li>
<li><p>read（读取）：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用</p>
</li>
<li><p>load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。</p>
</li>
<li><p>use（使用）：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。</p>
</li>
<li><p>assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</p>
</li>
<li><p>store（存储）：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。</p>
</li>
<li><p>write（写入）：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。</p>
<p>如果要把一个变量从主内存中复制到工作内存，就需要按顺寻地执行read和load操作，如果把变量从工作内存中同步回主内存中，就要按顺序地执行store和write操作。Java内存模型只要求上述两个操作必须按顺序执行，而没有保证必须是连续执行。也就是read和load之间，store和write之间是可以插入其他指令的，如对主内存中的变量a、b进行访问时，可能的顺序是read a，read b，load b， load a。Java内存模型还规定了在执行上述八种基本操作时，必须满足如下规则：</p>
</li>
<li><p>不允许read和load、store和write操作之一单独出现</p>
</li>
<li><p>不允许一个线程丢弃它的最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中。</p>
</li>
<li><p>不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步回主内存中。</p>
</li>
<li><p>一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。即就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作。</p>
</li>
<li><p>一个变量在同一时刻只允许一条线程对其进行lock操作，lock和unlock必须成对出现 如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值</p>
</li>
<li><p>如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量。</p>
</li>
<li><p>对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 主线程更新了num,无法通知线程A,程序无法终止</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class JmmDemo &#123;</span><br><span class="line"></span><br><span class="line">    private static int num &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            while(num &#x3D;&#x3D; 0)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,&quot;A&quot;).start();</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(2);</span><br><span class="line">        num &#x3D; 1;</span><br><span class="line">        System.out.println(&quot;num &#x3D; 1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="17-volatile"><a href="#17-volatile" class="headerlink" title="17.volatile"></a>17.volatile</h2><blockquote>
<p>保证可见性</p>
</blockquote>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 主线程更新了num,无法通知线程A,程序无法终止</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class JmmDemo &#123;</span><br><span class="line">    &#x2F;&#x2F;加volatile可以保证可见性</span><br><span class="line">    private volatile static int num &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            while(num &#x3D;&#x3D; 0)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,&quot;A&quot;).start();</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(2);</span><br><span class="line">        num &#x3D; 1;</span><br><span class="line">        System.out.println(&quot;num &#x3D; 1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>不保证原子性</p>
</blockquote>
<p>原子性：不可分割</p>
<p>线程A在执行任务的时候，不能被打扰的，也不能被分割。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;volatile不能保证原子性</span><br><span class="line">public class VolatileDemo &#123;</span><br><span class="line"></span><br><span class="line">    private volatile static int num &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    public  static void add()&#123;</span><br><span class="line">        num ++; &#x2F;&#x2F;不是原子性操作</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 20; i++) &#123;</span><br><span class="line">            new Thread(()-&gt;&#123;</span><br><span class="line">                for (int j &#x3D; 0; j &lt; 1000; j++) &#123;</span><br><span class="line">                    add();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while(Thread.activeCount()&gt;2)&#123;</span><br><span class="line">            &#x2F;**</span><br><span class="line">             * public static int activeCount()</span><br><span class="line">             * 返回当前线程的thread group及其子组中活动线程数的估计。 递归地遍历当前线程的线程组中的所有子组。</span><br><span class="line">             * 返回的值只是一个估计，因为线程数可能会在此方法遍历内部数据结构时动态更改，并且可能受某些系统线程的存在的影响。 此方法主要用于调试和监视。</span><br><span class="line">             *</span><br><span class="line">             * 结果</span><br><span class="line">             * 对当前线程的线程组和任何其他线程组中当前线程的线程组作为祖先的活动线程数的估计</span><br><span class="line">             *&#x2F;</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;num &#x3D; &quot; + num);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="JUC/image-20200423180425863.png" alt="image-20200423180425863"></p>
<p>使用AtomicInteger保证原子性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class VolatileDemo &#123;</span><br><span class="line"></span><br><span class="line">    private  static AtomicInteger num &#x3D; new AtomicInteger(0);</span><br><span class="line"></span><br><span class="line">    public  static void add()&#123;</span><br><span class="line">        num.getAndIncrement(); &#x2F;&#x2F;CAS</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 20; i++) &#123;</span><br><span class="line">            new Thread(()-&gt;&#123;</span><br><span class="line">                for (int j &#x3D; 0; j &lt; 1000; j++) &#123;</span><br><span class="line">                    add();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while(Thread.activeCount()&gt;2)&#123;</span><br><span class="line">            &#x2F;**</span><br><span class="line">             * public static int activeCount()</span><br><span class="line">             * 返回当前线程的thread group及其子组中活动线程数的估计。 递归地遍历当前线程的线程组中的所有子组。</span><br><span class="line">             * 返回的值只是一个估计，因为线程数可能会在此方法遍历内部数据结构时动态更改，并且可能受某些系统线程的存在的影响。 此方法主要用于调试和监视。</span><br><span class="line">             *</span><br><span class="line">             * 结果</span><br><span class="line">             * 对当前线程的线程组和任何其他线程组中当前线程的线程组作为祖先的活动线程数的估计</span><br><span class="line">             *&#x2F;</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;num &#x3D; &quot; + num);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>这些类的底层都直接和操作系统挂钩！在内存中修改值！Unsafe类是一个很特殊的存在！\</em></strong></p>
<blockquote>
<p> 禁止指令重排序</p>
</blockquote>
<p>什么是指令重排：你写的程序，计算机并不是按照你写的那样去执行的。</p>
<p>源代码-&gt;编译器优化的重排 -&gt;指令并行也可能会重排 -&gt;内存系统也会重排 -&gt; 执行</p>
<p><strong>处理器在进行指令重排的时候，考虑数据之间的依赖性！</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int x &#x3D; 1;&#x2F;&#x2F;1</span><br><span class="line">int y &#x3D; 2;&#x2F;&#x2F;2</span><br><span class="line">x &#x3D; x + 1;&#x2F;&#x2F;3</span><br><span class="line">y &#x3D; x * x;&#x2F;&#x2F;4</span><br><span class="line">我们所期望的： 1234 2134 1324</span><br><span class="line">但不能是3124</span><br></pre></td></tr></table></figure>

<p>可能造成影响的结果：a b x y这四个值默认都是0；</p>
<table>
<thead>
<tr>
<th>线程A</th>
<th>线程B</th>
</tr>
</thead>
<tbody><tr>
<td>x=a</td>
<td>y=b</td>
</tr>
<tr>
<td>b=1</td>
<td>a=2</td>
</tr>
</tbody></table>
<p>正常的结果：x=0;y=0;但是可能由于指令重排</p>
<table>
<thead>
<tr>
<th>线程A</th>
<th>线程B</th>
</tr>
</thead>
<tbody><tr>
<td>b=1</td>
<td>a=2</td>
</tr>
<tr>
<td>x=a</td>
<td>y=b</td>
</tr>
</tbody></table>
<p>指令重排导致的诡异结果：x=2;y=1;</p>
<p><img src="image-20200423183251016.png" alt="image-20200423183251016"></p>
<p><img src="image-20200423183328877.png" alt="image-20200423183328877"></p>
<h2 id="17-单例模式"><a href="#17-单例模式" class="headerlink" title="17.单例模式"></a>17.单例模式</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;饿汉模式</span><br><span class="line">public class HungryMan &#123;</span><br><span class="line"></span><br><span class="line">    private static final HungryMan hungryMan &#x3D; new HungryMan();</span><br><span class="line"></span><br><span class="line">    private HungryMan()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static HungryMan getInstance()&#123;</span><br><span class="line">        return hungryMan;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">&#x2F;&#x2F;        HungryMan hungryMan &#x3D; HungryMan.getInstance();</span><br><span class="line">&#x2F;&#x2F;        HungryMan hungryMan1 &#x3D; HungryMan.getInstance();</span><br><span class="line">&#x2F;&#x2F;        System.out.println(hungryMan);</span><br><span class="line">&#x2F;&#x2F;        System.out.println(hungryMan1);</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">            new Thread(()-&gt;&#123;</span><br><span class="line">                HungryMan hungryMan &#x3D; HungryMan.getInstance();</span><br><span class="line">                System.out.println(hungryMan);</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;懒汉模式</span><br><span class="line">public class LazyMan &#123;</span><br><span class="line"></span><br><span class="line">    private LazyMan()&#123;</span><br><span class="line">        synchronized (LazyMan.class)&#123;</span><br><span class="line">            if(lazyMan !&#x3D; null)&#123;</span><br><span class="line">                throw new RuntimeException(&quot;禁止通过反射破坏单例模式&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static volatile LazyMan lazyMan ;</span><br><span class="line"></span><br><span class="line">    public static LazyMan getInstance()&#123;</span><br><span class="line">        if(lazyMan &#x3D;&#x3D; null)&#123;</span><br><span class="line">            synchronized(LazyMan.class)&#123;</span><br><span class="line">                if(lazyMan &#x3D;&#x3D; null)&#123;</span><br><span class="line">                    &#x2F;**</span><br><span class="line">                     * 不是原子性操作：</span><br><span class="line">                     * 1.分配内存空间</span><br><span class="line">                     * 2.执行构造函数，初始化对象</span><br><span class="line">                     * 3.将这个对象指向该空间</span><br><span class="line">                     *&#x2F;</span><br><span class="line">                    lazyMan &#x3D; new LazyMan();</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return lazyMan;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException &#123;</span><br><span class="line">&#x2F;&#x2F;        for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">&#x2F;&#x2F;            new Thread(()-&gt;&#123;</span><br><span class="line">&#x2F;&#x2F;                LazyMan lazyMan &#x3D; LazyMan.getInstance();</span><br><span class="line">&#x2F;&#x2F;                System.out.println(lazyMan);</span><br><span class="line">&#x2F;&#x2F;            &#125;).start();</span><br><span class="line">&#x2F;&#x2F;        &#125;</span><br><span class="line">        &#x2F;&#x2F;通过反射破坏单例模式</span><br><span class="line">&#x2F;&#x2F;        LazyMan lm &#x3D; LazyMan.getInstance();</span><br><span class="line">&#x2F;&#x2F;        System.out.println(lm);</span><br><span class="line">        Constructor&lt;LazyMan&gt; declaredConstructor &#x3D; LazyMan.class.getDeclaredConstructor(null);</span><br><span class="line">        declaredConstructor.setAccessible(true);</span><br><span class="line">        LazyMan lazyMan1 &#x3D; declaredConstructor.newInstance(null);</span><br><span class="line">        LazyMan lazyMan2 &#x3D; declaredConstructor.newInstance(null);</span><br><span class="line">        LazyMan lazyMan3 &#x3D; declaredConstructor.newInstance(null);</span><br><span class="line">        System.out.println(lazyMan1);</span><br><span class="line">        System.out.println(lazyMan2);</span><br><span class="line">        System.out.println(lazyMan3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">import java.lang.reflect.Constructor;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 静态内部类</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Holder &#123;</span><br><span class="line">    private Holder()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Holder getInstance()&#123;</span><br><span class="line">        return InnerClass.HOLDER;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class InnerClass&#123;</span><br><span class="line">        public static Holder HOLDER &#x3D; new Holder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Holder holder1 &#x3D; Holder.getInstance();</span><br><span class="line">        Holder holder2 &#x3D; Holder.getInstance();</span><br><span class="line">        System.out.println(holder1);</span><br><span class="line">        System.out.println(holder2);</span><br><span class="line">        &#x2F;&#x2F;通过反射破坏单例模式</span><br><span class="line">        Constructor&lt;Holder&gt; declaredConstructor &#x3D; Holder.class.getDeclaredConstructor(null);</span><br><span class="line">        declaredConstructor.setAccessible(true);</span><br><span class="line">        Holder holder3 &#x3D; declaredConstructor.newInstance(null);</span><br><span class="line">        Holder holder4 &#x3D; declaredConstructor.newInstance(null);</span><br><span class="line">        System.out.println(holder3);</span><br><span class="line">        System.out.println(holder4);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">import java.lang.reflect.Constructor;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;枚举实现单例模式</span><br><span class="line">public enum EnumSingleton &#123;</span><br><span class="line"></span><br><span class="line">    SINGLETON;</span><br><span class="line"></span><br><span class="line">    public static EnumSingleton getInstance()&#123;</span><br><span class="line">        return SINGLETON;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        EnumSingleton enumSingleton1 &#x3D; EnumSingleton.getInstance();</span><br><span class="line">        EnumSingleton enumSingleton2 &#x3D; EnumSingleton.getInstance();</span><br><span class="line">        System.out.println(enumSingleton1);</span><br><span class="line">        System.out.println(enumSingleton2);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;试图通过反射破坏单例模式</span><br><span class="line">        &#x2F;&#x2F;Constructor&lt;EnumSingleton&gt; declaredConstructor &#x3D; EnumSingleton.class.getDeclaredConstructor(null);</span><br><span class="line">        &#x2F;&#x2F;declaredConstructor.setAccessible(true);</span><br><span class="line">        &#x2F;&#x2F;EnumSingleton enumSingleton &#x3D; declaredConstructor.newInstance(null);&#x2F;&#x2F;NoSuchMethodException</span><br><span class="line">        &#x2F;&#x2F;System.out.println(enumSingleton);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;jad -sjava EnumSingleton.class</span><br><span class="line">        &#x2F;&#x2F;Exception in thread &quot;main&quot; java.lang.IllegalArgumentException: Cannot reflectively create enum objects</span><br><span class="line">        Constructor&lt;EnumSingleton&gt; declaredConstructor &#x3D; EnumSingleton.class.getDeclaredConstructor(String.class, int.class);</span><br><span class="line">        declaredConstructor.setAccessible(true);</span><br><span class="line">        EnumSingleton enumSingleton &#x3D; declaredConstructor.newInstance(String.class, int.class);</span><br><span class="line">        System.out.println(enumSingleton);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="18-深入理解CAS"><a href="#18-深入理解CAS" class="headerlink" title="18.深入理解CAS"></a>18.深入理解CAS</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line">public class AtomicDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        AtomicInteger atomicInteger &#x3D; new AtomicInteger(2020);</span><br><span class="line"></span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(2020, 2021));</span><br><span class="line">        System.out.println(atomicInteger.get());</span><br><span class="line"></span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(2020, 2021));</span><br><span class="line">        System.out.println(atomicInteger.get());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CAS：比较当前工作内存中的值和主内存中的值，如果这个值是期望的，那么则执行操作！如果不是就一直循环！</p>
<p>缺点：</p>
<p>1.循环会耗时</p>
<p>2.一次只能保证一个共享变量的原子性</p>
<p>3.ABA问题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;ABA问题</span><br><span class="line">public class AtomicDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        AtomicInteger atomicInteger &#x3D; new AtomicInteger(2020);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;捣乱的线程开始</span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(2020, 2021));</span><br><span class="line">        System.out.println(atomicInteger.get());</span><br><span class="line"></span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(2021, 2020));</span><br><span class="line">        System.out.println(atomicInteger.get());</span><br><span class="line">        &#x2F;&#x2F;捣乱的线程结束</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;期望的线程</span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(2020, 6666));</span><br><span class="line">        System.out.println(atomicInteger.get());</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 执行结果：</span><br><span class="line">         * true</span><br><span class="line">         * 2021</span><br><span class="line">         * true</span><br><span class="line">         * 2020</span><br><span class="line">         * true</span><br><span class="line">         * 6666</span><br><span class="line">         *&#x2F;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;带版本号AtomicStampedReference，解决ABA问题</span><br><span class="line">public class ABADemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        AtomicStampedReference&lt;Integer&gt; atomicStampedReference &#x3D; new AtomicStampedReference(1, 1);</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            int stamp &#x3D; atomicStampedReference.getStamp();</span><br><span class="line">            System.out.println(&quot;a1 stamp:&quot; + stamp);</span><br><span class="line">            try &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(2);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;a2:&quot;+atomicStampedReference.compareAndSet(1, 2, atomicStampedReference.getStamp(), atomicStampedReference.getStamp() + 1));</span><br><span class="line">            System.out.println(&quot;a2:&quot;+atomicStampedReference.getReference()+&quot;,stamp:&quot;+atomicStampedReference.getStamp());</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;a3:&quot;+atomicStampedReference.compareAndSet(2, 1, atomicStampedReference.getStamp(), atomicStampedReference.getStamp() + 1));</span><br><span class="line">            System.out.println(&quot;a3:&quot;+atomicStampedReference.getReference()+&quot;,stamp:&quot;+atomicStampedReference.getStamp());</span><br><span class="line">        &#125;, &quot;A&quot;).start();</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            int stamp &#x3D; atomicStampedReference.getStamp();</span><br><span class="line">            System.out.println(&quot;b1 stamp:&quot;+stamp);</span><br><span class="line">            try &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(3);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;b:&quot;+atomicStampedReference.compareAndSet(1, 2, stamp, stamp + 1));</span><br><span class="line">            System.out.println(&quot;b:&quot;+atomicStampedReference.getReference()+&quot;,b stamp:&quot;+atomicStampedReference.getStamp());</span><br><span class="line">        &#125;, &quot;B&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="19-各种锁"><a href="#19-各种锁" class="headerlink" title="19.各种锁"></a>19.各种锁</h2><h4 id="1-公平锁、非公平锁"><a href="#1-公平锁、非公平锁" class="headerlink" title="1.公平锁、非公平锁"></a>1.公平锁、非公平锁</h4><p>公平锁：非常公平，不允许插队</p>
<p>非公平锁：非常不公平，可以插队（默认都是非公平锁）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Creates an instance of &#123;@code ReentrantLock&#125;.</span><br><span class="line"> * This is equivalent to using &#123;@code ReentrantLock(false)&#125;.</span><br><span class="line"> *&#x2F;</span><br><span class="line">public ReentrantLock() &#123;</span><br><span class="line">    sync &#x3D; new NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Creates an instance of &#123;@code ReentrantLock&#125; with the</span><br><span class="line"> * given fairness policy.</span><br><span class="line"> *</span><br><span class="line"> * @param fair &#123;@code true&#125; if this lock should use a fair ordering policy</span><br><span class="line"> *&#x2F;</span><br><span class="line">public ReentrantLock(boolean fair) &#123;</span><br><span class="line">    sync &#x3D; fair ? new FairSync() : new NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-可重入锁"><a href="#2-可重入锁" class="headerlink" title="2.可重入锁"></a>2.可重入锁</h4><p><img src="JUC/image-20200423223100203.png" alt="image-20200423223100203"></p>
<blockquote>
<p>synchronized</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;synchronized可重入锁</span><br><span class="line">public class LockDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Phone phone &#x3D; new Phone();</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            phone.sms();</span><br><span class="line">        &#125;, &quot;A&quot;).start();</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            phone.sms();</span><br><span class="line">        &#125;, &quot;B&quot;).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Phone &#123;</span><br><span class="line">    public synchronized void sms() &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot; SMS&quot;);</span><br><span class="line">        call();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void call() &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot; CALL&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>ReentrantLock</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;ReentrantLock 可重入锁</span><br><span class="line">public class LockDemo1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Phone phone &#x3D; new Phone();</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            phone.sms();</span><br><span class="line">        &#125;, &quot;A&quot;).start();</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            phone.sms();</span><br><span class="line">        &#125;, &quot;B&quot;).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Phone1 &#123;</span><br><span class="line">    private final Lock lock &#x3D; new ReentrantLock();</span><br><span class="line">    &#x2F;&#x2F;发短信</span><br><span class="line">    public void sms() &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot; SMS&quot;);</span><br><span class="line">            call();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;打电话</span><br><span class="line">    public void call() &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot; CALL&quot;);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-自旋锁"><a href="#3-自旋锁" class="headerlink" title="3.自旋锁"></a>3.自旋锁</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.concurrent.atomic.AtomicReference;</span><br><span class="line">&#x2F;&#x2F;自己写的自旋锁</span><br><span class="line">public class SpinLockDemo &#123;</span><br><span class="line"></span><br><span class="line">    AtomicReference&lt;Thread&gt; atomicReference &#x3D; new AtomicReference();</span><br><span class="line">    &#x2F;&#x2F;加锁</span><br><span class="line">    public void myLock()&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+&quot; myLock&quot;);</span><br><span class="line">        while(!atomicReference.compareAndSet(null,Thread.currentThread()))&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;解锁</span><br><span class="line">    public void myUnlock()&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot; myUnlock&quot;);</span><br><span class="line">        atomicReference.compareAndSet(Thread.currentThread(),null);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试自旋锁：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class TestSpinLock &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        SpinLockDemo spinLockDemo &#x3D; new SpinLockDemo();</span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            spinLockDemo.myLock();</span><br><span class="line">            try &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+ &quot;加锁！&quot;);</span><br><span class="line">                TimeUnit.SECONDS.sleep(3);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                spinLockDemo.myUnlock();</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;,&quot;T1&quot;).start();</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(1);</span><br><span class="line"></span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            spinLockDemo.myLock();</span><br><span class="line">            try &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+ &quot;加锁！&quot;);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                spinLockDemo.myUnlock();</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,&quot;T2&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-死锁"><a href="#4-死锁" class="headerlink" title="4.死锁"></a>4.死锁</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 死锁</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class DeadLockDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String lockA &#x3D; &quot;lockA&quot;;</span><br><span class="line">        String lockB &#x3D; &quot;lockB&quot;;</span><br><span class="line">        new Thread(new MyThread(lockA,lockB)).start();</span><br><span class="line">        new Thread(new MyThread(lockA,lockB)).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">class MyThread implements  Runnable&#123;</span><br><span class="line"></span><br><span class="line">    private String lockA;</span><br><span class="line">    private String lockB;</span><br><span class="line"></span><br><span class="line">    public MyThread(String lockA, String lockB) &#123;</span><br><span class="line">        this.lockA &#x3D; lockA;</span><br><span class="line">        this.lockB &#x3D; lockB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        synchronized (lockA)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot; lockA&quot;);</span><br><span class="line">            try &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(2);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            synchronized (lockB)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+&quot; lockB&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="JUC/image-20200423233831191.png" alt="image-20200423233831191"></p>
<p><img src="JUC/image-20200423233854319.png?lastModify=1587800694" alt="image-20200423233854319"></p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS滤镜</title>
    <url>/2020/04/25/CSS%E6%BB%A4%E9%95%9C/</url>
    <content><![CDATA[<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span>滤镜<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line">			img&#123;</span><br><span class="line">				width: 500px;</span><br><span class="line">				height: auto;</span><br><span class="line">				display: block;</span><br><span class="line">				margin: 0 auto;</span><br><span class="line">				transition: 2s;</span><br><span class="line">			&#125;</span><br><span class="line"><span class="css">			<span class="selector-class">.zjh</span>&#123;</span></span><br><span class="line"><span class="css">				<span class="comment">/* grayscale:设置灰度 1 百分之百 */</span></span></span><br><span class="line">				-webkit-filter: grayscale(1);</span><br><span class="line">			&#125;</span><br><span class="line"><span class="css">			<span class="selector-tag">img</span><span class="selector-pseudo">:hover</span>&#123;</span></span><br><span class="line">				-webkit-filter: none;</span><br><span class="line">				transition: 2s;</span><br><span class="line">			&#125;</span><br><span class="line"><span class="css">			<span class="selector-class">.zjh2</span>&#123;</span></span><br><span class="line"><span class="css">				<span class="comment">/* 曝光度 */</span></span></span><br><span class="line">				-webkit-filter: brightness(2);</span><br><span class="line">			&#125;</span><br><span class="line"><span class="css">			<span class="selector-class">.zjh3</span>&#123;</span></span><br><span class="line">				/* 褐色属性</span><br><span class="line">				 sepia 1 百分百褐色 正常0*/</span><br><span class="line">				-webkit-filter: sepia(1);</span><br><span class="line">			&#125;</span><br><span class="line"><span class="css">			<span class="selector-class">.zjh4</span>&#123;</span></span><br><span class="line"><span class="css">				<span class="comment">/* 模糊度 */</span></span></span><br><span class="line">				-webkit-filter: blur(5px);</span><br><span class="line">			&#125;</span><br><span class="line"><span class="css">			<span class="selector-class">.zjh5</span>&#123;</span></span><br><span class="line">				/* </span><br><span class="line">				 调整输入图像的对比度。的值0%将创建完全灰色的图像。</span><br><span class="line">				 值100%保持输入不变。</span><br><span class="line">				 100%允许超过的值，从而提供更具对比度的结果。</span><br><span class="line">				 内插的lacuna值为1。</span><br><span class="line">				 */</span><br><span class="line"><span class="css">				<span class="selector-tag">-webkit-filter</span>: <span class="selector-tag">contrast</span>(0<span class="selector-class">.5</span>);</span></span><br><span class="line">			&#125;</span><br><span class="line"><span class="css">			<span class="selector-class">.zjh6</span>&#123;</span></span><br><span class="line">				/* 使输入图像饱和。的值amount定义转换的比例。</span><br><span class="line">				值0%完全不饱和。值100%保持输入不变。其他值是效果的线性乘数。</span><br><span class="line">				100%允许超过的值，从而提供超饱和的结果。内插的lacuna值为1。 */</span><br><span class="line"><span class="css">				<span class="selector-tag">-webkit-filter</span><span class="selector-pseudo">:saturate(2)</span>;</span></span><br><span class="line">			&#125;</span><br><span class="line"><span class="css">			<span class="selector-class">.zjh7</span>&#123;</span></span><br><span class="line">				/* 反转输入图像中的样本。的值amount定义转换的比例。</span><br><span class="line">				值100%完全反转。</span><br><span class="line">				值0%保持输入不变。之间的值0%并且100%是在效果线性乘法器。</span><br><span class="line">				内插的lacuna值为0。 */</span><br><span class="line">				-webkit-filter: invert();</span><br><span class="line">			&#125;</span><br><span class="line"><span class="css">			<span class="selector-class">.zjh8</span>&#123;</span></span><br><span class="line">				/**</span><br><span class="line">				 * 在输入图像上应用色相旋转。</span><br><span class="line">				 的值angle定义将调整输入样本的色环周围的度数。</span><br><span class="line">				 值0deg 保持输入不变。内插的lacuna值为0。</span><br><span class="line">				 虽然没有最大值 上面的值的效果360deg回绕。</span><br><span class="line">				 */</span><br><span class="line"><span class="css">				<span class="selector-tag">-webkit-filter</span><span class="selector-pseudo">:hue-rotate(10deg)</span>;</span></span><br><span class="line">			&#125;</span><br><span class="line"><span class="css">			<span class="selector-class">.zjh9</span>&#123;</span></span><br><span class="line">				-webkit-filter: brightness(10) blur(1) grayscale(1);</span><br><span class="line">				transition: all 15s;</span><br><span class="line">			&#125;</span><br><span class="line"><span class="css">			<span class="selector-class">.zjh9</span><span class="selector-pseudo">:hover</span>&#123;</span></span><br><span class="line">				-webkit-filter: brightness(1) blur(0px) grayscale(1);</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">"zjh"</span> <span class="attr">src</span>=<span class="string">"img/jiangxin.png"</span> &gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">"zjh2"</span> <span class="attr">src</span>=<span class="string">"img/jiangxin.png"</span> &gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">"zjh3"</span> <span class="attr">src</span>=<span class="string">"img/jiangxin.png"</span> &gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">"zjh4"</span> <span class="attr">src</span>=<span class="string">"img/jiangxin.png"</span> &gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">"zjh5"</span> <span class="attr">src</span>=<span class="string">"img/jiangxin.png"</span> &gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">"zjh6"</span> <span class="attr">src</span>=<span class="string">"img/jiangxin.png"</span> &gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">"zjh7"</span> <span class="attr">src</span>=<span class="string">"img/jiangxin.png"</span> &gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">"zjh8"</span> <span class="attr">src</span>=<span class="string">"img/jiangxin.png"</span> &gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">"zjh9"</span> <span class="attr">src</span>=<span class="string">"img/jiangxin.png"</span> &gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>Jsoup爬取京东和融e购商品列表</title>
    <url>/2020/04/25/Jsoup%E7%88%AC%E5%8F%96%E4%BA%AC%E4%B8%9C%E5%92%8C%E8%9E%8De%E8%B4%AD%E5%95%86%E5%93%81%E5%88%97%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="1-新建maven项目，添加Jsoup的依赖"><a href="#1-新建maven项目，添加Jsoup的依赖" class="headerlink" title="1.新建maven项目，添加Jsoup的依赖"></a>1.新建maven项目，添加Jsoup的依赖</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Jsoup-demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.jsoup/jsoup --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jsoup<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsoup<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.13.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="2-新建实体类，代码如下："><a href="#2-新建实体类，代码如下：" class="headerlink" title="2.新建实体类，代码如下："></a>2.新建实体类，代码如下：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package cn.lxcourse.jsoup.pojo;</span><br><span class="line"></span><br><span class="line">import lombok.AllArgsConstructor;</span><br><span class="line">import lombok.Data;</span><br><span class="line">import lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line">@Data</span><br><span class="line">@NoArgsConstructor</span><br><span class="line">@AllArgsConstructor</span><br><span class="line">public class Content &#123;</span><br><span class="line">    private String price;</span><br><span class="line">    private String title;</span><br><span class="line">    private String imgSrc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-编写工具类，代码如下："><a href="#3-编写工具类，代码如下：" class="headerlink" title="3.编写工具类，代码如下："></a>3.编写工具类，代码如下：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package cn.lxcourse.jsoup.util;</span><br><span class="line"></span><br><span class="line">import cn.lxcourse.jsoup.pojo.Content;</span><br><span class="line">import org.jsoup.Jsoup;</span><br><span class="line">import org.jsoup.nodes.Document;</span><br><span class="line">import org.jsoup.nodes.Element;</span><br><span class="line">import org.jsoup.select.Elements;</span><br><span class="line"></span><br><span class="line">import java.net.URL;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 爬虫工具</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class JsoupUtils &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 爬取京东商品列表</span><br><span class="line">     * @param keywords</span><br><span class="line">     * @return</span><br><span class="line">     * @throws Exception</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static List&lt;Content&gt; getJDGoods(String keywords) throws Exception &#123;</span><br><span class="line">        String url &#x3D; &quot;https:&#x2F;&#x2F;search.jd.com&#x2F;Search?keyword&#x3D;Java&quot; + keywords;</span><br><span class="line">        Document document &#x3D; Jsoup.parse(new URL(url), 300000);</span><br><span class="line">        &#x2F;&#x2F;商品列表</span><br><span class="line">        Element j_goodsList &#x3D; document.getElementById(&quot;J_goodsList&quot;);</span><br><span class="line">        Elements glEtemElements &#x3D; j_goodsList.getElementsByClass(&quot;gl-item&quot;);</span><br><span class="line"></span><br><span class="line">        List&lt;Content&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        for (Element element : glEtemElements) &#123;</span><br><span class="line"></span><br><span class="line">            String imgSrc &#x3D; element.getElementsByTag(&quot;img&quot;).eq(0).attr(&quot;source-data-lazy-img&quot;);</span><br><span class="line">            String price &#x3D; element.getElementsByClass(&quot;p-price&quot;).eq(0).text();</span><br><span class="line">            String title &#x3D; element.getElementsByClass(&quot;p-name&quot;).eq(0).text();</span><br><span class="line"></span><br><span class="line">            Content content &#x3D; new Content();</span><br><span class="line">            content.setImgSrc(imgSrc);</span><br><span class="line">            content.setPrice(price);</span><br><span class="line">            content.setTitle(title);</span><br><span class="line"></span><br><span class="line">            list.add(content);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 爬取工行融e购商品列表</span><br><span class="line">     * @param keywords</span><br><span class="line">     * @return</span><br><span class="line">     * @throws Exception</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static List&lt;Content&gt; getRongYiGouGoods(String keywords) throws Exception &#123;</span><br><span class="line">        &#x2F;&#x2F;https:&#x2F;&#x2F;mall.icbc.com.cn&#x2F;searchproducts&#x2F;pv.jhtml?query&#x3D;java</span><br><span class="line">        String url &#x3D; &quot;https:&#x2F;&#x2F;mall.icbc.com.cn&#x2F;searchproducts&#x2F;pv.jhtml?query&#x3D;&quot; + keywords;</span><br><span class="line"></span><br><span class="line">        Document document &#x3D; Jsoup.parse(new URL(url), 30000);</span><br><span class="line">        Element ajaxQueryContent &#x3D; document.getElementById(&quot;ajaxQueryContent&quot;);</span><br><span class="line"></span><br><span class="line">        Elements liElements &#x3D; ajaxQueryContent.getElementsByTag(&quot;li&quot;);</span><br><span class="line"></span><br><span class="line">        List&lt;Content&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        for (Element el : liElements) &#123;</span><br><span class="line">            String src &#x3D; el.getElementsByTag(&quot;img&quot;).eq(0).attr(&quot;src&quot;);</span><br><span class="line">            String price &#x3D; el.getElementsByClass(&quot;p-price&quot;).eq(0).text();</span><br><span class="line">            String title &#x3D; el.getElementsByClass(&quot;p-name&quot;).eq(0).select(&quot;a&quot;).eq(0).attr(&quot;title&quot;);</span><br><span class="line">            Content content &#x3D; new Content();</span><br><span class="line">            content.setTitle(title);</span><br><span class="line">            content.setPrice(price);</span><br><span class="line">            content.setImgSrc(src);</span><br><span class="line">            list.add(content);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        &#x2F;&#x2F;getJDGoods(&quot;Java&quot;).forEach(System.out::println);</span><br><span class="line">        getRongYiGouGoods(&quot;java&quot;).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo搭建blog</title>
    <url>/2020/03/31/hexo%E6%90%AD%E5%BB%BAblog/</url>
    <content><![CDATA[<h1 id="MacOS从零开始搭建hexo博客"><a href="#MacOS从零开始搭建hexo博客" class="headerlink" title="MacOS从零开始搭建hexo博客"></a>MacOS从零开始搭建hexo博客</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol>
<li>前期准备</li>
<li>安装hexo</li>
<li>生成SSH并添加到github</li>
<li>部署项目</li>
<li>上传到github</li>
<li>绑定个人域名</li>
<li>修改及配置主题</li>
</ol>
<hr>
<h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><pre><code>1. 安装git
2. 安装node.js
    查看node.js版本号
    node -v 
    npm -v
3.安装cnpm
    查看cnpm的版本号
    cnpm -v</code></pre><hr>
<h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">安装hexo命令：cnpm install -g hexo-cli</span><br><span class="line">查看hexo版本号：hexo -v</span><br><span class="line">初始化命令：hexo init blog</span><br><span class="line">解释一下：</span><br><span class="line">    node_modules：是依赖包</span><br><span class="line">    public：存放的是生成的页面</span><br><span class="line">    scaffolds：命令生成文章等的模板</span><br><span class="line">    <span class="built_in">source</span>：用命令创建的各种文章</span><br><span class="line">    themes：主题</span><br><span class="line">    _config.yml：整个博客的配置</span><br><span class="line">    db.json：<span class="built_in">source</span>解析所得到的</span><br><span class="line">    package.json：项目所需模块项目的配置信息</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="创建github-repo"><a href="#创建github-repo" class="headerlink" title="创建github repo"></a>创建github repo</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">创建repo,名称为myname.github.io,myname与github用户名保持一致。</span><br><span class="line">git config --global user.name <span class="string">"my-name"</span></span><br><span class="line">git config --global user.email <span class="string">"my-email"</span></span><br><span class="line">ssh-keygen -t rsa -C <span class="string">"my-email"</span></span><br><span class="line">配置ssh,Settings -&gt; SSH and GPG keys -&gt; New SSH key</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="打开blog项目，修改-config-yml配置文件"><a href="#打开blog项目，修改-config-yml配置文件" class="headerlink" title="打开blog项目，修改_config.yml配置文件"></a>打开blog项目，修改_config.yml配置文件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repo: https://github.com/my-github-name/my-github-name.github.io.git</span><br><span class="line">  branch: master</span><br><span class="line"><span class="comment"># 进入blog目录，执行下列命令：</span></span><br><span class="line">hexo new <span class="string">"博客名称"</span></span><br><span class="line">hexo clean</span><br><span class="line">hexo generate</span><br><span class="line">hexo server</span><br><span class="line"><span class="comment">#打开浏览器，输入http://localhost:4000,可以看到博客效果了。</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="上传到github"><a href="#上传到github" class="headerlink" title="上传到github"></a>上传到github</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">执行命令：npm install hexo-deployer-git --save</span><br><span class="line">然后执行：</span><br><span class="line">hexo clean</span><br><span class="line">hexo generate</span><br><span class="line">hexo deploy</span><br><span class="line">打开浏览器，输入http://my-github-name.github.io，查看效果。</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="绑定个人域名"><a href="#绑定个人域名" class="headerlink" title="绑定个人域名"></a>绑定个人域名</h2><pre><code>在blog/source目录下新建名为CNAME的文件，文件中添加自己的域名，保存退出</code></pre><hr>
<h2 id="修改及配置主题"><a href="#修改及配置主题" class="headerlink" title="修改及配置主题"></a>修改及配置主题</h2><pre><code>以ayer为例，进入blog目录，执行命令：git clone https://github.com/Shen-Yu/hexo-theme-ayer.git themes/ayer
修改_config.yml,修改主题为：
    theme: ayer
然后执行：
hexo clean
hexo generate
hexo deploy    </code></pre><hr>
<h2 id="打开自己域名，查看效果"><a href="#打开自己域名，查看效果" class="headerlink" title="打开自己域名，查看效果"></a>打开自己域名，查看效果</h2>]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
